const AYA_STDLIB = {"base/char.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `char` type\n\n{,\n    .#? C.islower\\n  tests if a character is lowercase\n    {$ 'a :> \\ 'z :< &}:islower;\n\n    .#? C.isupper\\n  tests if a character is uppercase\n    {$ 'A :> \\ 'Z :< &}:isupper;\n\n    .#? C.toupper\\n  converts a character to uppercase\n    {$.isupper! {!} ? }:upper;\n\n    .#? C.tolower\\n  converts a character to lowercase\n    {$.islower! {!} ? }:lower;\n\n    .#? C.isdigit\\n  tests if a character is a digit\n    {$ '0 :> \\ '9 :< &}:isdigit;\n\n    .#? C.iswhitespace\\n  tests if a character is a whitespace character\n    { \" \\f\\n\\r\\t\\v\\{x00A0}\\{x2028}\\{x2029}\" \\ H}:iswhitespace;\n\n    .#? C.isascii\\n  test if character is ascii\n    {:' 127 <}:isascii;\n\n    .#? C.isalpha\\n  test if character is alphabetical\n    {$ $ 'a :> \\ 'z :< & \\ $ 'A :> \\ 'Z :< & |}:isalpha;\n\n    .#? ::str ::char .split_keep\\n  split the string at the char, keep the char in the leading string\n    {s c,\n        s c S #{c+} \n\n        .# If c is not the last char of s,\n        .# remove c from the last item of the list\n        s.[-1]c=! {\n            :&.[-1]B;\\.:[-1]\n        } ? \n        \n    }:split_keep;\n}\n.# Merge with char metatable\n'x .M \\.+\n", "base/sym.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `sym` type\n\n{,\n    .{? ::sym .op\n\n        Return a block containing the operator\n        Does not currently work with quoted operators (TODO: fix internal representation)\n\n        aya> ::+ .op\n        {+}\n        aya> ::Ms .op\n        {Ms}\n        aya> ::\"Ms\" .op\n        Error\n    .}\n    {sym, \n        ::ops Ma\n        .# filter out items where the symbol doesn't match\n        :# {k v, v.overload sym H {v}?}\n        .# Grab the `call` block\n        :V.[0].call.`\n    }:op;\n\n    .# Get a dict of all operator/symbol pairs\n    {,\n        \"overloadable\" M? :# {\n            .# Get <name> <op> as strings\n            :& \"overloadable:.*$\" & .[0] \" \" S .[-1] \\ \" \" S .[0]\n            .# Lambda to apply to each <name> <op>\n            ({name op,\n                .# If the name is \"__add__/__radd__\", only use the first one\n                name '/ S .[0]:name;\n                .# Attempt to parse the op ( operator __each__ \":#\" will fail)\n                .# And assign the op to its name\n                {op.~ name :=} {;} .K\n            })\n        }\n    }:_overloads;\n\n    {s, {::_.M._overloads s I} {; s :C.~ } .K }:op;\n\n\n    .{? ::sym .rev\n\n        Return the reverse overload for a symbol\n        - If the symbol is an operator and has a reverse overload, return it\n        - If the symbol is an operator but does not have a reverse overload,\n            return the original operator\n        - If the symbol is not an operator, throw an error\n\n        aya> ::+ .rev\n        ::__radd__\n    .}\n\n    {,\n        .# Get the overload list for all ops\n        ::ops Ma :#{.overload}\n        .# Get all ops with non-zero length overloads\n        .[{E 0 = !}]\n        .# For each overload list\n        :V :#{l,\n            .# Assign the reversed op to the standard one\n            .# If the list length is 1, standard will be assigned to itself\n            l.[-1] l.[0] :=\n        }\n    }:_rev_overloads;\n\n    { ::_.M._rev_overloads \\ I }:rev;\n\n}\n.# Merge with sym metatable\n::_ .M \\.+\n", "base/test.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# test.aya\n.# Defines an interface for testing aya code\n\n{, } :test;\n\n.# New simpler test function\n{blk,\n.{\n    {\n        blk :!\n    } {ex,\n        ex.` :T ::dict = {\n            ex ::type 0 .I ::assert_err = {\n                [\"Test Failed: $blk\"\n                 \"\\tExpected: $(ex.expected.`)\"\n                 \"\\tReceived: $(ex.received.`)\"] \"\\n\"* :P\n            } {\n                ex .D\n            } .?\n        } {\n            ex .D\n        } .?\n    } .K\n\n.}\n    blk :!\n} test.:test;\n", "base/importlib.aya": "module importlib\n\ndef importlib::_debug 0\n\ndef importlib::_log_debug {:importlib^,\n     importlib._debug {\"importlib: \" \\+ :P} {;} .?\n}\n\ndef importlib::aya_dir :{sys.ad}\n\n.# Dictionary of files which have been imported\ndef importlib::imported {,}\n\ndef importlib::path [\n    importlib.aya_dir \"std\" :9s + +    .# <aya>/base\n]\n\n.# Return the path with the current directory at the bottom\ndef importlib::get_path { : importlib^ ,\n    importlib.path\n    :{sys.wd}\n    J\n}\n\n.# Return a dictionary with the file loaded in it\n.# If the file is already loaded, return the item from the dict\ndef importlib::load_file {filename : importlib^,\n    \"$filename importlib::load_file\" importlib._log_debug\n    importlib.imported filename H {\n        .# Return from the cache\n        \"Loading file $filename from cache\" importlib._log_debug\n        importlib.imported.[filename]\n    } {\n        { .# try\n            \"Attempting to open file $filename...\" importlib._log_debug\n            .# Load the file into a dict scope\n            {,\n                .# If __main__ exists and is 0, `main` will discard its block\n                .# Otherwise it will execute it\n                0:__main__;\n                .# The filename of the file being loaded\n                filename :__file__;\n                .# 1: export all\n                .# 0: left in default state\n                .# []: export nothing\n                .# [syms...] export given names\n                0:__export__;\n                filename :F\n            } :& importlib.imported.:[filename];\n            \"Loaded file $filename\" importlib._log_debug\n        } {e,\n            \"Error importing '$filename':\\n\\t$e\" .D\n        } .K\n    } .?\n}\n\n\n.# A file is main if `__main__` is undefined or not 0\ndef importlib::is_main {\n    { .# try\n        __main__ 0 =!\n    } {;\n        1\n    } .K\n}\n\n.{\n    ::foo => \"foo\"\n    \"foo\" => \"foo\"\n    \"foo.bar\" => \"foo/bar\"\n    \"foo/bar\" => \"foo/bar\"\n.}\ndef importlib::to_path_str {s,\n    s :C \"\\.\" \"/\" .& \".aya\" +\n}\n\n.# Import from path\n.{\n    import \"foo\"\n\n    Use __* variables so exported variables are not shadowed\n.}\ndef importlib::from_path {__file : importlib^ __mod,\n    \"$__file importlib::from_path\" importlib._log_debug\n\n    __file importlib.to_path_str importlib.from_file :__mod;\n\n    __file __mod importlib.do_export\n}\n\n.{\n    Export variables from a module\n    If symbols are defined in the module's __export__ variable,\n        only export those ones,\n    If __export__ is the value 1, export all variables from the module\n    If __export__ does not exist but the import name was a symbol,\n        export the entire module as the name of the symbol\n\n.}\ndef importlib::do_export {__importname __module : importlib^,\n    \"$__importname <module> importlib::export\" importlib._log_debug\n    \"  export: $(__module.__export__)\" importlib._log_debug\n    {\n        (__module ::__export__ H!) {\n            \"__export__ not found in module $__importname. Was it deleted?\" .D\n        } (__module.__export__ 1 =) {\n                \"Exporting all variables from $__importname...\" importlib._log_debug\n                .# Introduce scope to catch any names we never want to export\n                ({: __export__ __main__ __file__,\n                    __module W\n                })\n        } (__module.__export__ 0 =) {\n            (__importname :T ::sym =) {\n                \"Exporting entire module as import name: $__importname\" importlib._log_debug\n                __module __importname :=;\n            } {\n                \"Export in default state but import is not a symbol, not exporting anything\" importlib._log_debug\n            } .?\n        } (__module.__export__ :T ::list =) {\n            \"Exporting variables from $__importname\" importlib._log_debug\n            __module.__export__ :# {var,\n                \"  exporting $var...\" importlib._log_debug\n                __module var I var :=;\n            };\n        } {\n            \"Invalid value for __export__ when importing $__importname: $(__module.__export__)\" .D\n        }\n    } :?\n}\n\n.{\n    Directly append the file to each of the paths and attempt to load\n    Example input:\n    filepath: (\"foo.aya\", \"bar/baz.aya\", \"/Users/user/foo.aya\")\n.}\ndef importlib::from_file {filepath : importlib^ all_possible mod,\n    \"$filepath importlib::from_file\" importlib._log_debug\n\n    importlib.get_path :# { filepath + } :~ :all_possible\n    .# Get only files that exist\n    { :{sys.file_exists} } I\n    .# If the lists is empty, throw an error\n    .E 0 = {\"Import Error: Unable to find any of the following files: $all_possible\" .D} ?\n\n    .# Returns a dict containing the imported content\n    .[0] importlib.load_file\n}\n\n.{\n    name may be any of the following:\n    ::foo (symbol)\n    \"foo\" (single item)\n    \"foo bar\" (whitespace seperated)\n    \"foo\\nbar\" (whitespace seperated)\n    [::foo ::bar] (list of symbols)\n    [\"foo\" \"bar\"]  (list of strings)\n    \"foo.baz\" (file baz in dir foo)\n\n    Use __* variables so exported variables are not shadowed\n.}\ndef importlib::import {__name : importlib^,\n    {\n        (__name :T ::sym =) {\n            __name importlib.from_path\n        } (__name :T ::str =) {\n            { .# Determine load command based on string type\n                (__name \".aya\" H) {\n                    __name importlib.from_file\n                } (__name.[0] '/ =) {\n                    __name importlib.load_file\n                } {\n                    __name importlib.from_path\n                }\n            } :?\n        } (__name :T ::list =) {\n            __name :# {importlib.import} ;\n        } {\n            \"Bad name type: $__name\" .D\n        }\n    } :?\n}\n\n\n\ndef importlib::is_exportall {\n    { .# try\n        __export__ 1 =\n    } {;\n        0\n    } .K\n}\n\ndef importlib::export {vars : importlib^,\n    .# Only make any changes if not exporting all already\n    importlib.is_exportall ! {\n        .# Get the currently exported\n        {__export__;} {e, []:__export__;} .K\n        .# If exported is default (0), set it to a list\n        __export__ 0 = {[]:__export__;} ?\n        .# Add new exported\n        {\n            (vars 1 =) {\n                1 :__export__;\n            } (vars :T ::sym =) {\n                vars __export__ .B ;\n            } (vars :T ::list =) {\n                vars __export__ J :__export__;\n            } {\n                \"export error: cannot export $vars\" .D\n            }\n        } :?\n    } ?\n}\n\n.# Import certain symbols from a module\ndef importlib::from {mod_sym import_vars : meta_mod importlib^,\n    \"$mod_sym $import_vars importlib.from\" importlib._log_debug\n    \"from: Capturing all imported vars...\" importlib._log_debug\n    {,\n        mod_sym importlib.import\n    }:meta_mod;\n\n    import_vars :T ::sym = {[import_vars]:import_vars;} ?\n\n    \"from: exporting variables...\" importlib._log_debug\n    import_vars :# {var,\n        { .# try\n            .# Export the variable from the imported module\n            meta_mod.[mod_sym].[var] var := ;\n            \"from:   exporting '$var'...\" importlib._log_debug\n        } {\n            { .# try\n                .# The variable was exported into the meta module and\n                .# does not exist in the inner module\n                meta_mod.[var] var := ;\n            } {\n                \"Import Error: $var does not exist in module $mod_sym\" .D\n            } .K\n        } .K\n    };\n}\n\nimportlib __aya__.:importlib;\n\n.# If provided a 0 (for example from `from` keyword), do nothing\n{(1 hold)(:& 0= {;} {__aya__.importlib.import} .?)}:import;\n\n{: importlib^ , {,} importlib.:imported; } :reimport;\n\n{(1 hold)(__aya__.importlib.export)}:export;\n{1:__export__;} :exportall;\n\n.# from ::math import [::sin ::cos]\n.# from ::io import ::path\n{\n    {:&.[0]~ \\.[-1]~ __aya__.importlib.from} 3 :` \n}:from;\n\n.# main {do stuff...}\n.# Do not execute this block if the file it is contained in\n.# is being imported as a module\n{(1 hold)(\n    __aya__.importlib.is_main {~} {;} .?\n)}:main;\n", "base/block.aya": "{,\n\n    .# Functional Operations\n    .########################\n\n    .#? ::list ::list ::block.pu\\n  (permusing) permutes elements of two lists and applies an expression to each\n    .{ Example:\n        aya> \"AB\" \"ab\" {P+}.pu\n        [[\"Aa\" \"Ab\"][\"Ba\" \"Bb\"]]\n        aya> [1 2 3][4 5 6] {P+}.pu\n        [[4 5 6][8 10 12][12 15 18]]\n    .}\n    {la lb ex, [lb la lbEL,\\#{ex}]}:pu;\n\n\n    .#? ::list ::block.tw\\n  (takewhile) take from list while the condition is satisfied\n    .{ Example:\n        aya> 10R {5<}.tw\n        [ 1 2 3 4 ]\n    .}\n    {e,{e!}.N $0= {;;[]} {S~;} .? }:tw;\n\n\n    .#? ::any ::list ::block.el\\n  apply block to `any` and `i` for each element across list\n    .{ Example:\n        aya> \"a\" [\"A\" \"B\" \"C\"] {+}.el\n        [\"aA\" \"aB\" \"aC\"]\n    .}\n    {@@.E@\\L\\@.&}:el;\n\n\n    .#? ::list ::any ::block.le\\n  apply block to `any` and `i` for each element across list\n    .{ Example:\n        aya> [\"A\" \"B\" \"C\"] \"a\" {+}.le\n        [\"Aa\" \"Ba\" \"Ca\"]\n    .}\n    {@@\\.E@\\L@.&}:le;\n\n\n    .#? ::block.haslocals\\n  return true if the block has a local variables\n    .# Both the args and the locals mush be empty for this to be false\n    {.| :&.locals:E \\.argsE + 0 =!}:haslocals;\n\n\n    .#? ::block.locals\\n  get the locals of a block\\n  will throw error if block does not have locals\n    {.|.locals}:locals;\n\n\n    .#? ::block.args\\n  get an ordered list of argument descriptions to the block\\n  empty list if there are none\n    {.|.args}:args;\n\n    .#? ::block .use ::list\\n  evaulate the variables (given by a list of symbols) in the block in the current scope\n    .{ Example:\n        aya> 2:y\n        2\n        aya> {x, x y *}.use[::y] :double\n        {x , x 2 * }\n        aya> 3 double\n        6\n    .}\n    {(1 hold)({:d__,\n        .# Create a dictionary of all values given by the list\n        {,}:d__;\n        :#{$~\\d__:D;};\n        .# Substitute the values from the dictionary into the block\n        d__ .+\n    })}:use;\n\n    .#? ::block .time\\n  return the result of the block and the execution time in ms\n    {:a__, M$:a__; ~ M$ a__ -} :time;\n\n    .# Utility Functions\n    .#####################\n\n\n    .# ::list _capture_vars\\n  given a list of symbols, return a dict with each symbol and it's assignment\n    .{ Example:\n        aya> {1 +}:a 2:b\n        {1 +} 2\n        aya> [::a ::b].capture_vars\n        {,\n          {1 +}:a;\n          2:b;\n        }\n        aya> [::a ::b ::c].capture_vars\n        ERROR: Variable c not found\n    .}\n    { {1, :# {$~\\:=} } }:_capture_vars;\n\n\n    .#? ::block .op\\n  return the block (allows use of (::sym or ::block) .op without type checking\n    {}:op;\n\n}\n.# Merge with char metatable\n{} .M \\.+\n\n.# Define operators\n{.le}:otimes;\n{.el}:odot;\n", "base/num.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `num` type\n\n{,\n\n    .#? ::num .digits\\n  convert a number into a list of digits\n    {\n        Z           .# Convert to bignum\n        .|          .# Absolute value (ignore negative)\n        P B;V;      .# Remove the ': and 'z\n        '. S V \\;   .# Remove any decimal\n        #:'         .# Convert to list of ascii values\n        48-         .# Subtract 48 (ascii value of '0)\n    }:digits;\n\n\n    .#? ::num .bits\\n  return binary representation of the integer\n    {.| 10 2 .&}:bits;\n\n    .#? ::num .bytes\\n  return byte list representation of the integer\n    {10 0 .&}:bytes;\n\n\n    .#? ::num .round\\n  round a decimal to the nearest whole value\n    {0.49999999-./}:round;\n\n\n    .#? ::num ::num.fixed\\n  round N1 to N2 decimal digits\n    {E$@@*.\\\\/}:fixed;\n\n\n    .#? n::nun lo::num hi::num .clip N1 between N2 (lo) and N3 (hi)\n    .# Reverse the order of min/max algorithms depending on sign\n    {@ .> .<}:clip;\n\n\n    .#? ::num.i\\n  generate a range from -N to N\n    .{ Example:\n        aya> 4.i\n        [ -4 -3 -2 -1 0 1 2 3 4 ]\n        aya> 1.i\n        [ -1 0 1 ]\n        aya> -1.i\n        [ 1 0 -1 ]\n    .}\n    {\n        $           .# dup n so we can use the sign later\n        .| $TR\\R    .# create negative and positive versions of the list\n        0\\:J:J        .# join lists with a 0 between\n        \\0<{U}?     .# If the sign is negative, reverse\n    }:i;\n\n\n    .#? ::num.frac\\n  the fractional part of the number\n    { 1:% }:frac;\n\n\n    .#? ::num.s\\n  split a decimal into two numbers\n    .{ Example:\n        aya> 4.6 .s\n        4 6\n        aya> 0.3 .s\n        0 3\n        aya> 5 .s\n        5 0\n    .}\n    {\n        $1:%P$.[0]'.={V;}?~ \\.\\ \\\n    }:fracsplit;\n\n}\n.# Merge with num metatable\n0 .M \\.+\n\n", "base/__aya__.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n\n.# __aya__\n.# Defines the __aya__ namespace and keywords\n\n.# NOTE: 12 letter variables ending in the letter 'z' are reserved for use in\n.#       standard library. Such variables are used below.\n\n{:{sys.ad} \"test/test.aya\" + :F}:tt;\n\n.# Global __aya__ table\n{,\n\n    {,}:interpreter;\n\n    .# If set to 1, all breakpoints will be ignored\n    .#? __aya__.ignore_breakpoints\\n  if true, skip all breakpoints\n    0 :ignore_breakpoints;\n\n}:__aya__;\n\n{,\n    {, \n        ::__nil :__type__;\n        \"nil\" :__str__;\n        \"nil\" :__repr__'\n        1 :__pushself__;\n        {:T ::__nil =}:__eq__;\n    }:__meta__;\n}:nil;\n\n.#######################################\n.# DEFINE __aya__ KEYWORDS AND GLOBALS #\n.#######################################\n\n.# -----\n.# DEBUG\n.# -----\n\n.#? bp\\n  set a breakpoint\n{ : __aya__^,\n    __aya__.ignore_breakpoints ! {\n        :{debug.pause}\n    } ?\n}:bp;\n\n\n.# Hold operator (same as `)\n.# 1 `+ 1\n.# 1 (1 hold)+ 1\n.# ``+ 1 1\n.# (2 hold)+ 1 1\n{__hold_n, {__hold_f : __hold_n^, {:__hold_f^, {~} O ~ __hold_f} __hold_n :` } 0 :` }:hold;\n\n.# ----\n.# LOAD\n.# ----\n\n.#? load S\\n  Load a script\n{{~\".aya\"+:F} 0 :`}:load;\n\n\n.# -------\n.# EXAMPLE\n.# -------\n\n{name,\n    [:{sys.ad} :9s \"examples\" :9s name \".aya\"] W :F\n}:example;\n\n\n\n.# -------\n.# OPT_MOD\n.# -------\n\n.{\n    Macro for creating a macro which runs a different block\n    depending on whether or not a module is present as an argument\n\n    .# Example:\n\n    opt_mod (\n        {block name mod,\n            \"with_mod!\" :P [block.` name mod]\n        }\n\n        {block name,\n            \"no mod!\":P [block.` name]\n        }\n    )\n\n    aya> f {,} ::foo {\"a\"}\n    with_mod!\n    [ {\"a\"} ::foo {,} ]\n\n    aya> f ::foo {\"a\"}\n    no mod!\n    [ {\"a\"} ::foo ]\n.}\n\n{with_mod no_mod,\n\n    {:with_mod no_mod,\n\n        .# Use constant substitution until var^ syntax is introduced\n        _with_mod:with_mod;\n        _no_mod:no_mod;\n\n        .# Store functions on stack so they can be retrieved later\n        {,\n            no_mod.` :no_mod\n            with_mod.` :with_mod\n        }\n\n        (3 hold)(\n            .# Variable argument prefix operator\n            .# aya> {mod name block, mod ::_fn =! {;} ? [mod name block.`]} :f\n\n            .# Jump ahead 3 items\n            .# aya> (```(\\:&:T ::sym=! {\\`}{\\}.? f) ::_fn)   {,} ::foo {+}\n            .# [ {,} ::foo {+} ]\n\n            .# Jump ahead 2 items\n            .# aya> (```(\\:&:T ::sym=! {\\`}{\\}.? f) ::_fn)   ::foo {+}\n            .# [ ::_fn ::foo {+} ]\n\n            \\:&:T ::sym=! {\\(1 hold)}{\\}.?\n\n\n            ( {mod name obj : is_module with_mod no_mod,\n\n                .# True if this function is being defined in a module\n                .# fn foo::bar {...}\n                .# False if defined in outer scope\n                .# fn ::bar {...}\n                mod ::_opt_mod =! :is_module;\n\n                .# If a module was provided, remove the ::_opt_mod symbol from the stack\n                is_module {;} ?\n\n                W .# Capture with_mod and no_mod from outer dict\n\n                .# Quote obj in case it is a block\n                is_module {\n                    obj.` name mod with_mod\n                } {\n                    obj.` name no_mod\n                }\n                .?\n            } )\n\n        )\n        ::_opt_mod\n    }\n\n    .# Use constant substitution until var^ syntax is introduced\n    {, no_mod.`:_no_mod with_mod.`:_with_mod} .+\n\n} __aya__.:opt_mod;\n\n\n.# -----\n.#  DEF\n.# -----\n\n\n.{\n    `def` macro\n    Universal verbose syntax for defining functions\n\n    Define a function in the current scope:\n\n        aya> def ::double {2*}\n        aya> 3 double\n        6\n\n    Define a function in a module scope:\n\n        aya> {,}:math;\n        aya> def math::sq {2^}\n        aya> 5 math.sq\n        25\n\n    Define a function in a class/struct scope:\n\n        aya> struct point {x y}\n        aya> def point::sum {self, self.x self.y +}\n        aya> 2 3 point! :p\n        ( 2 3 ) point!\n        aya> p.sum\n        5\n\n    Define a function in a submodule:\n\n        aya> {, {,}:stats; }:math;\n        aya> def (math.stats)::mean {.E\\W\\/}\n        aya> [1 2 3 4] math.stats.mean\n        2.5\n.}\n\n(\n    {block name mod,\n        block.` name mod :D ;\n    }\n    {block name,\n        block.` name := ;\n    }\n) __aya__.opt_mod :def;\n\n\n.# ----------------\n.#  CLASS / STRUCT\n.# ----------------\n\n\n.#\n.# `objcet`: Base object for class and struct\n.#\n{,\n    {meta : instance,\n        {,\n            meta :__meta__;\n            1 :__pushself__;\n        } :instance;\n\n        .# If it has a constructor call it\n        instance ::__init__ H {\n            instance.__init__\n        } ?\n\n        .# return the new object\n        instance\n    }:__new__;\n\n\n    {self,\n        \"($(self.__type__:C) 0x$(self M# 10 16 .&))\"\n    }:__repr__;\n\n    ::object:__type__;\n    0 :__pushself__;\n\n} __aya__.:object;\n\n\n.#\n.# `extend`: Keyword for extending a class\n.#\n\n{type::sym super,\n    {,\n        super:__meta__;\n        type:__type__;\n        .# copy new from super directly\n        super.__new__.` :__new__;\n        0:__pushself__;\n    } type :=\n} __aya__.:extend;\n\n__aya__.extend.` :extend;\n\n\n.#\n.# `class`: Macro keyword for creating a default class that extends `object`\n.#\n\n{: extend^ object(__aya__.object),\n    {:extend^ object^, ~:S~ object extend;} 1 :`\n}:class;\n\n\n.#\n.# `super`: Macro keyword for accessing super variables\n.#\n\n{{\n    ~:S~\n    \\:&.__meta__.__meta__@ :I\\; ~\n} 1 :` }:super;\n\n\n.#\n.# `struct`: Macro keyword for creating dataclasses\n.#\n\n{type__::sym members__::list super__ :\n    extend__(extend.`)\n    cls__,\n\n    type__ super__ extend__ : cls__;\n\n    .# __init__\n    {self,\n        .# grab all members from the stack\n        num_members :A\n        .# and assign them to self\n        members {self :D} .&;\n    } {,\n        members__ E :num_members;\n        members__   :members;\n    } .+ cls__.:__init__;\n\n    .# __str__/__repr__\n    .# default string:\n    .# ( m1 m2 ... mN ) type!\n    {self,\n        \"( \"\n        members :# {self \\:I \\;} \" \" % +\n        \" ) \" +\n        name  +\n        \"!\"+\n    } {,\n        type__ :C   :name;\n        members__ :members;\n    } .+ cls__.:__str__;\n\n    cls__.__str__.` cls__.:__repr__;\n\n    cls__\n} __aya__.:_struct_impl;\n\n{ : _struct_impl(__aya__._struct_impl.`) object(__aya__.object),\n    { : _struct_impl^ , :&.[0]:S~ \\.[1]~.*:#{:S~} object _struct_impl } 2 :`\n}:struct;\n\n\n.# ------\n.# MODULE\n.# ------\n\n.#? module sym\\n  declare a new module\n{name::sym,\n    {,\n        name :__modname__;\n\n        {meta,\n            \"Cannot create new instance of module $(meta.__modname__:C)\" .D\n        } :__new__;\n\n        {,\n            ::module :__type__;\n            \"(module $name)\":__repr__;\n        }:__meta__;\n    }\n    name := ; .# assign variable\n} __aya__.:_module_impl;\n\n\n{ : _module_impl(__aya__._module_impl.`),\n    { : _module_impl^ , ~:S~ _module_impl} 1 :`\n}:module;\n\n\n.###########\n.# CONTROL #\n.###########\n\n\n.#? if (B) E E\\n  if statement:\\n  if (bool value) {\\n    then\\n  } {\\n    else\\n  }\n{(3 hold).?}:if;\n\n\n.#? dowhile E E\\n  evaluates E1 as long as E2 is true\\n  always evaluates at least once\n{(2 hold)({condition__ loop__,\n    {loop__ condition__} W\n})}:dowhile;\n\n\n.#? while E E\\n  evaluates E1 as long as E2 is true\n{(2 hold)({condition__ loop__,\n    condition__ {\n        {loop__ condition__} W\n    } ?\n})}:while;\n\n.#? A print\\n  convert to string a print to console\n{.P}:print;\n\n\n.#? A println\\n  convert to string and print to console on its own line\n{:P}:println;\n\n\n.{ Example:\n    aya> with {\"foo\" file.dummyfile!} ::f {\"File name is $(f.name)\" :P}\n    opened dummy file 'foo'\n    File name is foo\n    closed dummy file 'foo'\n    aya> with {\"foo\" file.dummyfile!} ::f {\"File name is $(f.name)\" :P \"Some error!\".D }\n    opened dummy file 'foo'\n    File name is foo\n    closed dummy file 'foo'\n    Some error!\n    stack:\n\n    just before:\n            {::f .Z .close} ~\n.}\n{(3 hold)(__aya__.with_ ~)}:with;\n\n\n.#? ::any ::sym isa\\n  returns true if the item's type matches the input\n{item::any type::sym,\n   type ::any = {\n       1\n   } {\n       item type :@\n   } .?\n}:isa;\n\n\n.# Helper function for `with` keyword which generates wrapper code\n.{\n    with {\"foo.txt\" file!} ::f {\n      f.lines #:P\n    }\n{init::block var::sym code::block: try catch close,\n    {init~ var := ; code~}.use[::init ::code ::var] :try ;\n    {var.Z .close .D}.use[::var] :catch ;\n    {var.Z .close}.use[::var] :close ;\n    {try catch .K close~}.use[::try ::catch ::close]\n    .setlocals[var]\n}__aya__.:with_;\n.}\n\n\n.################\n.# import types #\n.################\n\n[\n    \"test\"\n    .# Type extensions\n    \"num\"\n    \"char\"\n    \"list\"\n    \"str\"\n    \"block\"\n    \"sym\"\n\n    .# required libraries\n    \"importlib\"\n\n    .# Interpreter commands\n    \"interpreter\"\n\n] :# {f,\n    .# \"Loading base/$f...\" :P\n    load ([:{sys.ad} :9s \"base/$f\"]W)\n};\n", "base/str.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# string.aya\n.# Defines functions for working with strings and regular expressions\n\n{,\n    .# Import list variables\n    [].M W\n\n\n    {\"\\\\s+\" S E0=}:iswhitespace;\n\n    .#? ::str.trim\\n  remove whitespace from start and end of string\n    {\n        :& .iswhitespace {\n            ; \"\"\n        } {\n            \"^\\\\s+\" S B\\; \"\\\\s+$\" S V\\; \n        } .?\n    }:trim;\n\n\n    .#? ::num ::char ::str .leftpad\\n  left pad string S so it is at least length I using char C\n    {len::num pad::char s,\n        s.E len\\- {pad\\:J}\\O\n    }:lpad;\n\n\n    .#? ICS.rightpad\\n  right pad string S so it is at least length I using char C\n    {len::num pad::char s,\n        s.E len\\- {pad:J}\\O\n    }:rpad;\n\n\n    .# S.tolower\\n  convert string to uppercase\n    {:#{.upper}}:upper;\n\n\n    .# S.toupper\\n  convert string to lowercase\n    {:#{.lower}}:lower;\n\n\n    .#? S.isnum\\n  returns true if the string is a valid number\n    {.! :T ::num =}:isnum;\n\n\n    .#? S.titlecase\\n  convert a string to titlecase\n    {s,\n        s ERB; # {i,\n            s.[iV] .iswhitespace {\n                s.[i].upper s.:[i];\n            } ?\n        };\n        s.[0].upper s.:[0];\n        s\n    }:titlecase;\n\n\n    .#? S.lines\\n  split a string into lines. ignore traling newlines\n    {\"\\n\"S}:lines;\n\n\n    .#? S.bytes\\n  convert string to byte list\n    {:'}:bytes;\n\n\n    .#? S.parsenum\\n  If num, return num, else return str (rm surrounding quotes)\n    {\n        .!\n        $:T ::str = {\n            .# If it is a string, test if it has quotes and remove them\n            .trim $ [0 -1]I \"\\\"\\\"\" = {B;V;} ?\n        } ?\n    }:parsenum;\n\n\n    .#? sep S.readdlm\\n  convert a csv string into a 2d list\n    {sep s,\n        sepP:sep;\n        s.lines :# {\n            sep S :# {.parsenum}\n        }\n        .makesquare\n    }:readdlm;\n\n\n    .#? ::str ::str .endswith\\n  test if a string 1 ends with string 2\n    {:&E@\\.>=}:endswith;\n\n    .#? ::str .rmquote\\n  remove single leading/trailing quote characters if they exist\n    .# aya> \"A\".rmquote\n    .# \"A\"\n    .# aya> \"\\\"A\\\"\".rmquote\n    .# \"A\"\n    .# aya> \"\\\"A\\\"b\".rmquote\n    .# \"\"A\"b\"\n    {s,\n        {\n            (s E 2 <) {\n                s\n            } (s.[-1] '\" = s.[0] '\" = &) {\n                s $ \\ ; B ; V ;\n            } {\n                s\n            }\n        } :?\n    }:rmquote;\n\n}\n\n\n.# Merge with str metatable\n\"\" .M \\.+\n\n\n", "base/list.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metatable definition for the built-in `list` type\n\n{,\n    .# Querying\n    .###############\n\n    .#? ::any ::list .in\\n  tests whether or not item is in the list\n    {\\H}:in;\n\n    .#? ::list .max\\n  max value of a list\n    {{.<}%}:max;\n\n    .#? ::list .min\\n  min value of a list\n    {{.>}%}:min;\n\n    .#? ::list .argmax\\n  return the index of the largest value in the list\n    {$.maxN\\;}:argmax;\n\n    .#? ::list .argmin\\n  return the index of the smallest value in the list\n    {$.minN\\;}:argmin;\n\n    .#? ::list ::list .i\\n  index using mask\n    {.ER*{0=!}I1#- .E0={;;[]} {.E@@I\\ 1={A}?} .?}:i;\n\n    .#? ::list ::list.mask\\n  select indices with non-false values from list\n    .{\n        aya> [1 2 3 4 5] [0 1 0 0 1].mask\n        [ 2 5 ]\n    .}\n    {a b,\n        aE bE = {\n            a b .E R * .[{0=!}] 1- I\n        } {\n            \"::list.mask: both lists must be the same length\" .D\n        } .?\n    }:mask;\n\n    .#? ::list.alleq\\n  return true if all items in the list are the same\n    {:~E1:<}:alleq;\n\n    .#? ::list .allt\\n  true if all elements in list are true\n    {{&}%}:allt;\n\n    .#? ::list .allf\\n  true if all elements in list are false\n    {{|}%!}:allf;\n\n    .# Convenience functions for using a list as a vector\n    {.[0]}:x;\n    {.[1]}:y;\n    {.[2]}:z;\n    {.:[0]}:setx;\n    {.:[1]}:sety;\n    {.:[2]}:setz;\n\n\n    .# Manipulation\n    .###############\n\n\n    .#? ::any ::list .append\\n  add item to end of list\n    {.B}:append;\n\n    .#? ::list .pop\\n  remove item from end of list\n    {B}:pop;\n\n    .#? ::list .roll\\n  move the last element to the front\n    {B\\.V}:roll;\n\n    .#? ::num ::list .rotate\\n  shift items in list up N times wrappping the items around\n    .{ Example:\n        aya> 1 [1 2 3 4].rotate\n        [ 4 1 2 3 ]\n        aya> 2 [1 2 3 4].rotate\n        [ 3 4 1 2 ]\n        aya> -1 [1 2 3 4].rotate\n        [ 2 3 4 1 ]\n    .}\n    {\n        .E@-        .# inverse so rotate in correct direction 2 5R => 3\n        \\.E@\\:%     .# force bounds: n % length\n        S ~ \\ :J    .# Split, swap, and rejoin\n    }:rotate;\n\n\n    .#? ::num ::num ::list .swap\\n  swap two elements in a list given their indices\n    {i::num j::num l::list: tmp,\n        l i I : tmp;\n        l j I  l i D;\n        tmp l j D\n    }:swap;\n\n\n    .#? ::list .shuffle\\n  shuffle a list\n    {{;.Q}.C}:shuffle;\n\n\n    .#? ::list .makesquare\\n  make all lists in the given 2d lists the same length\n    {list,\n        list$ #E {.<} %\n        #.<\n    }:makesquare;\n\n\n    .# Generators\n    .#############\n\n    .#? ::list.r\\n  multidimentional range\n    .{ Example:\n        aya> [2 3].r\n        [ [ 1 2 3 ] [ 4 5 6 ] ]\n    .}\n    {${*}%R\\L}:r;\n\n    .#? ::list.zeros\\n  generate a [N1 x N2 x ...] list of zeros\n    .#? ::list.ones\\n  generate a [N1 x N2 x ...] list of ones\n    .{? Example:\n        aya> [2 3].zeros\n        [ [ 0 0 0 ] [ 0 0 0 ] ]\n        aya> [4].ones\n        [ 1 1 1 1 ]\n    .}\n    {${*}%0\\L\\L}:zeros;\n    {${*}%1\\L\\L}:ones;\n\n    .#? ::any ::num ::list .lpad\\n  left pad list using ::any to a max length of ::num\n    { .E @ \\- 0.< @\\L\\J }:lpad;\n    .#? ::any ::num ::list .rpad\\n  left pad list using ::any to a max length of ::num\n    { .E @ \\- 0.< @\\L J }:rpad;\n\n    .#? ::list ::num .pad\\n 2d padding\n    {n l, l:En+$n+\\~ l\\#.>\\.> \\~@ \\#.<\\.<}:pad;\n\n\n    .#? ::any ::list .surround\\n  append A to the front and back of L\n    {$\\; \\$@J\\J}:surround;\n\n    .#? ::list .enumerate\\n  return a list of index-value pairs for the list\n    {.E.R{A.B}.&}:enumerate;\n\n    .#? ::list .rank\\n  rank a list from highest to lowest\n    {${>}.pu#W1+}:rank;\n\n    .#? ::list .irange\\n generates a range of indices for the list\n    {E.R}:irange;\n\n\n\n    .# OTHER UTILITIES\n    .##################\n\n    .#? ::list.dict_flatten\\n  given a list of dicts, flatten the into a single dict\n    {\n        {,}\\J{.+}%\n    }:dict_flatten;\n\n\n    .#? ::list .matstr\\n  convert a 2d list into a string with evenly spaced columns\n    .{ Example:\n        aya> [[\"A\" \"B\" \"CCC\"][\"D\" \"EE\" \"F\"]] .matstr :P\n        A B  CCC\n        D EE F\n        aya> [[\"A\" pi \"CCC\"][\"hello world\" \"EE\" 2]] .matstr :P\n        A           3.14159265 CCC\n        hello world EE         2  \n    .}\n    def ::matstr {m : colmax,\n        m :#{#{PE}}.T:#{{.<}%}:colmax;      .# The max width for each column\n        m .T colmax {#{\\P\\ B.<}} .& .T      .# For each colum, convert to string with\n                                            .# padding equal to the max for that column + 1\n        :#{WB;}                             .# Combine each row into a single string, remove trailing space\n        '\\n' %                              .# Join with newlines\n    }\n\n    {\\.S}:rotate_rows;\n    {\\0\\J.S}:rotate_cols;\n}\n.# Merge with list metatable\n[] .M \\.+\n\n\n.# Removing .I, can directly swap for this\n{\\:&@I}:dot_i;\n", "base/interpreter.aya": ".# Defines \\t interpreter flag\n\n{\n    .# Create a block from the input and time the execution\n    .~ .time\n    .# Print the results of the block\n    .AB\\ #{.P\" \".P}; \"\":P\n    .# Print execution time message\n    \"Execution took \"\\+\" ms\"+:P\n\n} __aya__.interpreter.:t\n", "std/viewmat.aya": "import ::canvas\n\nexport ::viewmat\nexport ::viewmat_scaled\n\n\ndef ::viewmat_scaled { data scale : cvs canvas^,\n    .# special case for matrix\n    data :T ::matrix = {data.rows :data;} ?\n\n    {,\n        data E :height;\n        data.[0] E :width;\n        scale :scale;\n        \"viewmat\" :name;\n    } canvas! :cvs;\n\n    data cvs.viewmat\n\n    cvs\n}\n\ndef ::viewmat { data : width height scale size viewmat_scaled^,\n    .# special case for matrix\n    data :T ::matrix = {data.rows :data;} ?\n\n    data E :height;\n    data.[0] E :width;\n    width height .< :size;\n\n    .# Set a reasonable scale\n    1 :scale;\n    size 400 :< { 2:scale; } ?\n    size 100 :< { 8:scale; } ?\n    size 40  :< { 16:scale; } ?\n    size 10  :< { 64:scale; } ?\n\n    data scale viewmat_scaled\n}\n", "std/unit.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# unit.aya\n.# Note: This file is currently deprecated.\n.#       It will be reintroduced at a later time.\n\n.{ Todo:\n   Make all units objects\n   Overload operators\n     \"1ft 12in +\"~ => 2ft\n     \"1mile 1hour /\" => 1mph\n     \"3hour 1mph *\" => 3mile\n.}\n\n{,\n\n    .# Length\n\n    0.001:mm:milimeter;\n    0.01:cm:centimeter;\n    1:m:meter;\n    1000:km:kilometer;\n    0.0254:in:inch;\n    0.3048:ft:feet;\n    0.9144:yd:yard;\n    1609.34:mi:mile;\n    1852:nmile:nauticalm;\n\n    .# Mass\n\n    0.000001:mg:milligram;\n    0.001:g:gram;\n    1:kg:kilogram;\n    1016.05:lton:longton;\n    907.185:shton:shortton;\n    6.35029:st:stone;\n    0.453592:lb:pound;\n    0.0283495:oz:ounce;\n\n    .# Time\n\n    1:s:second;\n    60:min:minute;\n    3600:hr:hour;\n    86400:day;\n    604800:week;\n    31536000:yr:year;\n\n    :1e-3:milisecond:ms;\n    :1e-6:microsecond;\n    :1e-9:nanosecond:ns;\n\n\n    .# Data\n\n    1:bit;\n    1000:kilobit:kib;\n    1000 kilobit *:megabit:mib;\n    1000 megabit *:gigabit:gib;\n    1000 gigabit *:terabit:tib;\n    8:byte;\n    1000 byte *:kilobyte:kb;\n    1000 kilobyte *:megabyte:mb;\n    1000 megabyte *:gigabyte:gb;\n    1000 gigabyte *:terabyte:tb;\n\n\n}:unit;\n\n\n.# Conversion functions (Uncomment to use)\n\n.# Type saftey version\n{(1 hold)({num::num from::num to::num, num from * to/})}:to;\n\n.# Regular Version\n.#\t{(1 hold)(\\@*\\/)}:to;\n\n{,\n    {(1 hold)({sub super : super_type,\n        super.__type__ :super_type;\n        super ::__type__ .- ;\n        sub super .+ ;\n        super_type super.:__type__;\n    })}:extends\n\n    class time\n\n    def time::__init__ {n self,\n        n self._to_sec self.:s;\n    }\n\n    def time::to_sec {self,\n        self.s\n    }\n\n    def time::__str__ {self,\n        self.s self._from_sec \" \" +\n        self :T :C +\n    }\n\n    def time::__repr__ (time.__str__.`)\n\n    def time::_to_sec {n self,\n        n self.scale_factor *\n    }\n\n    def time::_from_sec {n self,\n        n self.scale_factor /\n    }\n\n    def time::__add__ {a b,\n    }\n\n\n    class minute\n\n    minute extends time\n\n    def minute::scale_factor 60\n\n\n    class hour\n\n    hour extends time\n\n    def hour::scale_factor (60 60 *)\n\n} :time;\n\n{:time^, time.minute!}:minute;\n{:time^, time.hour!}:hour;\n\n", "std/golf.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# golf.aya\n.# Defines operators and variables useful for golfing\n\nexportall\n\n.# Import standard library\n:{sys.ad} \"/std\"+ :{sys.readdir}:# {\".aya\" S W :S} :# {name,\n    name ::golf = ! {\n        import name\n    } ?\n} ;\n\n.# Standard library shortcuts\n{,\n    0 .M :num;\n    'x.M :char;\n    [].M :list;\n    \"\".M :str;\n\n    num.clip.`   num.:c;\n    num.digits.` num.:d;\n    num.round.`  num.:r;\n    num.bits.`   num.:b;\n    num.bytes.`  num.:a;\n\n    char.upper.` char.:u;\n    char.lower.` char.:l;\n\n    str.upper.`  str.:u;\n    str.lower.`  str.:l;\n    str.trim.`   str.:t;\n    str.lines.`  str.:n;\n\n    list.shuffle.` list.:q;\n    list.max.` list.:u;\n    list.min.` list.:l;\n    list.irange.` list.:i;\n}\n\nmatrix.rotate_cols.` matrix.:n;\nmatrix.rotate_rows.` matrix.:z;\n\n.# Single letter variables\n\n1:a;\n2:b;\n3:c;\n10:d;\n:1c:e;\ndataframe:f;\n.#:g;\n.#:h;\n.#:i;\n.#:j;\n1000:k;\n{[]}:l;\nmatrix:m;\n'\\n':n;\n.#:o;\n:0c :p;\n.#:q;\n{.R}:r;\n.#:s;\n.#:t;\n.#:u;\n.#:v;\n-1 :w;\n0:x;\n0:y;\n0:z;\n\n\n.# Single byte variables\n\n{=!} \"\\{not}\" := ;\n{:P} \"\\{thorn}\" := ;\n{:;:P} \"\\{THORN}\" := ;\n{2^} \"\\{sup2}\" := ;\n.# pop font/back shortcuts\n{B\\;} \"\\{iacute}\" := ;\n{V\\;} \"\\{igrave}\" := ;\n\n\n.# cdict variables\n{,\n  \"()\" :\"(\";\n  \"<>\" :\"<\";\n  \"/\\\\\":\"^\";\n  \"{}\" :\"{\";\n  \"[]\" :\"[\";\n\n  [1 2]  :\"\u00bd\";\n  [1 -1] :\"+\";\n  [-1 1] :\"-\";\n  [0 1]  :\".\";\n  [0 0]  :\"0\";\n  [1 1]  :\"1\";\n  [2 2]  :\"2\";\n  360    :\"3\";\n  128    :\"4\";\n  256    :\"8\";\n\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" :\"A\";\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" :\"B\";\n  \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\" :\"C\";\n  \"012345679\" :\"D\";\n  \"0123456789ABCDEF\" :\"H\";\n  :-7s :\"P\"; .# printable ascii\n  [\"QWERTYUIOP\" \"ASDFGHJKL\" \"ZXCVBNM\"] :\"Q\";\n  \"AEIOUaeiou\" :\"V\";\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\" :\"W\";\n\n}:__cdict__;\n", "std/io.aya": "export [\n    ::path\n    ::file\n    ::stdout\n    ::stdin\n    ::fileutils\n]\n\n\nclass path\n\n.# Create a new path (accepts relative or abs paths)\n.# Custom constructor\n{dir meta : absolute_path(0),\n    .# Already a path?\n    dir:T ::path = {\n        dir\n    } {\n        .# Input is a string?\n        dir:T ::str = {\n            .# If direct path\n            dir meta._isabs ! {\n                0 :absolute_path;\n            } {\n                1 :absolute_path;\n            } .?\n            {,\n                dir meta._split :dirs;\n                absolute_path :is_absolute_path;\n            } meta :M\n        } {\n            \"Cannot create path from $dir\" .D\n        } .?\n    } .?\n} path.:__new__;\n\n\n.# ::path.isfile\\n  Return true if path is file (last item in the path contains a \".\")\ndef path::isfile {self,\n    self.dirs.[-1] \".\" H\n}\n\n\n.#? ::str ::path.add\\n  append file or dir to path, if path is file, don't change\ndef path::__add__ {dir::str self,\n    .# Can only join if the path is not a file\n    self.isfile ! { : newpath ,\n        .# Make a copy of this path\n        self $ :newpath; ;\n        newpath.dirs dir path._split J\n        path._clean newpath.:dirs;\n        newpath\n    } {\n        self\n    }.?\n}\n\ndef path::__radd__ {\\.__add__}\n\n\n.# String representation of the path\ndef path::__str__ {self,\n    self.dirs \"/\" %\n    self.is_absolute_path self._iswindows ! & {\n        \"/\" \\ +\n    } ?\n    .#self.dirs :9s % self.M.root :9s + \\+\n    .#self.isfile ! {:9s +} ?\n}\n\n(path.__str__.`,0); path.:__repr__;\n\n\n.#? ::path.dec\\n  Go up a directory\ndef path::__dec__ {self,\n    self.dirs B;; self\n}\n\n.#? ::str path.readdir\\n  list of file/dir names in the given path\ndef path::readdir {path,\n    P :{sys.readdir}\n}\n\n.#? path.working\\n  working directory\ndef path::working {path,\n    :{sys.wd} path!\n}\n\n.#? path.aya\\n  aya directory\ndef path::aya {path,\n    :{sys.ad} path!\n}\n\ndef path::clean {self,\n    self.dirs self._clean self.:dirs;\n}\n\n\n.#\n.# Private helper methods\n.#\n\n\n.# ::str path.split\\n  split a string using the system file sepatator and remove empty dir names\ndef path::_split {dir::str path,\n    dir '\\\\' S #{'/ S ~}\n    .# Remove empties\n    [\"\"] :|\n}\n\n.# dirs::list path._fixhome\n.# If the path list contains a \"~\"\n.#   find the last \"~\" and take all directories after it\ndef path::_fixhome {dirs::list path,\n    dirs U \"~\" N    .# Reverse and find the first ~ (aka the last ~)\n\n    .# Does the path contain a \"~\" ?\n    $ 0 :> {\n        .< U .# Take all directories before the \"~\" and reverse\n\n        .# Append the home dir to the front\n        path.home.dirs $\\;  .# Copy home.dirs\n        \\ :J                .# Append to front\n    } {\n        ;U .# Pop the -1 and put the list back\n    } .?\n}\n\n.# ::str path._isabs\\n  return true of the given string is an absolute path\ndef path::_isabs {p::str path,\n\tpath._iswindows {\n\t\tp 1 I ': =\n\t} {\n\t\tp \"/\" N0=\\;\n\t} .?\n}\n\n.# Remove all \"..\" by traversing the directories\ndef path::_clean {dirs::list path : i(0),\n    .# Remove root and self refs (\".\")\n    dirs [path.root \".\"] :| :dirs;\n\n    .# If there is a \"..\" remove the dir before it\n    {{\n        .# If there is a \"..\",\n        dirs.[iB] \"..\" = {\n            .# Remove the \"..\" and the dir before it\n            dirs [i iB] .-;\n            .# Then move the index back 2\n            i2-:i;\n        } ?\n        ::iB\n        i dirs EV <\n    }W}\n    .# If the above code has an error, the path is invalid\n    {; []:dirs;} .K\n    dirs\n}\n\ndef path::_iswindows {self,\n\t:9s \"\\\\\" =\n}\n\n\n\n.#\n.# Constants\n.#\n\n.#? path.root\\n  root dir name\n\"user.dir\" :{sys.getprop} :9s .^ S .[0] path.:root;\n\n\n\n\"~\" :{sys.resolvehome} path! path.:home;\n\n{, :{sys.wd} path._split :dirs} path :M path.:dfltworking;\n\n\n\n.####################\n.# FILE             #\n.####################\n\nclass file\n\ndef file::__init__ {filepath type::char  self : path^,\n    .# save a copy of the path\n    filepath path!      self.:path ;\n    .# open the stream\n    self.path P type :{fstream.O} self.:id ;\n}\n\n.#? ::file.close\\n  close a file. return 1 is success\ndef file::close {self,\n    self.flush;\n    self.id 'c :{fstream.O}\n}\n\n.#? ::file.isopen\\n  test if a file stream is open\ndef file::isopen {self,\n    self.id 'i :{fstream.O} 0 =!\n}\n\n.#? ::file.isread\\n  return 1 if file is an input stream\ndef file::isinput {self,\n    self.id 'i :{fstream.O} 1 =\n}\n\n.#? ::file.iswrite\\n  return 1 if file is an output stream\ndef file::isoutput {self,\n    self.id 'i :{fstream.O} 2 =\n}\n\n.#? ::file.print\\n  print to a file if it is an input stream\ndef file::print {s self,\n    sP self.id :{fstream.O}\n}\n\n.#? ::file.println\\n  print string followed by a newline tp a file\ndef file::println {s self,\n    sP \"\\n\" + self.id :{fstream.O}\n}\n\n.#? ::file.readchar\\n  read the next char in the file, return -1 if EOF or invalid stream\ndef file::readchar {self,\n    self.id 'b :{fstream.O}\n}\n\n.#? ::file.readline\\n  read the next line in the file, return 0 is EOF or invalid stream\ndef file::readline {self,\n    self.id 'l :{fstream.O}\n}\n\n.#? ::file.readall\\n  read all text in the stream, return \"\" if EOF and 0 if invalid stream\ndef file::readall {self,\n    self.id 'a :{fstream.O}\n}\n\n.#? ::file.lines\\n  return a list containing the lines in the file\ndef file::lines {self,\n    self.id 'a :{fstream.O} '\\n' S\n}\n\n.#? ::file.flush\\n  flush an output stream\ndef file::flush {self,\n    self.id 'f :{fstream.O}\n}\n\ndef file::__repr__ {self,\n    [\n        self.isopen\n            {\"<stream(\" self.isinput {\"R\"} {\"W\"} .? \"):\"}\n            \"<closed:\"\n        .?\n        self.path P \">\"\n    ]W\n}\n\n\n.{ Example:\n\n    \"file.txt\" 'r file!.do {f,\n        f.readll :P\n    }\n.}\ndef file::do {self,\n    {:self^, ~ self._do} 0 :`\n}\n\n.# Helper function for file.do\ndef file::_do {blk__::block self__,\n    {\n        self__ blk__\n    } {e,\n        self__.close;\n        e .D .# re-throw\n    } .K\n    self__.close;\n}\n\n.#? stdin::file\\n  standard input stream\n{,\n    1:id;\n\n    .# Overloads\n    1:isopen;\n    0:close;\n    1:isread;\n    0:iswrite;\n    \"stdin\":path;\n} file :M :stdin;\n\n.#? stdout::file\\n  standard output stream\n{,\n    2:id;\n\n    .# Overloads\n    1:isopen;\n    0:close;\n    1:iswrite;\n    0:isread;\n    \"stdout\":path;\n} file :M :stdout;\n\n\n\n.# dummyfile for testing opening and closing of input streams\n\nclass dummyfile\nexport ::dummyfile\n\ndef dummyfile::__init__ {name self,\n    \"opened dummy file '$name'\" :P\n    name self.:name;\n}\n\ndef dummyfile::__repr__ {self,\n    \"<dummyfile: $(self.name)>\"\n}\n\ndef dummyfile::close {self,\n    \"closed dummy file '$(self.name)'\" :P\n}\n\ndummyfile file.:dummyfile ;\n\n\n{,\n    {path, .# ::path or ::str\n        path P :{fileutils.readallbytes}\n    }:readallbytes;\n\n}:fileutils;\n", "std/date.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# date.aya\n.# Defines the date type\n\n.{? type: date\n    The date type provides operations for accessing date and time variables.\n.}\n\nexport [::date ::dates ::dateunit]\n\n{,\n\n    ::date :__type__;\n    1 :__pushself__;\n\n    {{,M$:ms} date :M}:now;\n\n    .# {in meta, [\n    .#     in:T ::num = {{,in:ms} meta :M} ?\n    .#     in:T ::str = {{,in \"yyyy-MM-dd\" :{date.parse}:ms} meta :M} ?\n    .#     {\"Expected S|D, recieved: $in\".D}\n    .# ].S }:__new__;\n\n    {in meta,\n        {\n            (in :T ::num =) {\n                {, \n                    in:ms\n                } meta :M\n            } (in :T ::str =) {\n                {, \n                    in \"yyyy-MM-dd\" :{date.parse} :ms;\n                } meta :M\n            } {\n                \"Expected ::str or ::num. recieved: $in\" .D\n            }\n        } :?\n    }:__new__;\n\n    {.ms \"MMM dd, yyyy h:mm:ss a\" :{date.format}}:__repr__;\n    {.__repr__}:__str__;\n\n    {.ms :{date.desc}.day_of_week}:dayofweekid;\n    {.ms :{date.desc}.day_of_week dates.weekdays\\V I}:dayofweek;\n    {.ms :{date.desc}.day_of_week dates.weekdaysabb\\V I}:dayofweekabb;\n    {.ms :{date.desc}.year}:year;\n    {.ms :{date.desc}.month}:monthid;\n    {.ms :{date.desc}.month dates.monthnames\\I}:month;\n    {.ms :{date.desc}.month dates.monthsabb\\I}:monthabb;\n    {.ms :{date.desc}.day_of_month}:dayofmonth;\n    {.ms :{date.desc}.hour}:hour:h;\n    {.ms :{date.desc}.minute}:min:m;\n    {.ms :{date.desc}.second}:sec:s;\n    {.ms\"a\":{date.format}}:ampm;\n\n    {self unit,\n        self.ms unit.ms + date!\n    }:__radd__;\n\n    {self unit,\n        self.ms unit.ms - date!\n    }:__rsub__;\n\n    {.ms}:__sort__;\n\n    .# Parse Functions\n    {\"MM/dd/yy\" :{date.parse}}:parsemdy;\n\n    .# String functions\n    {.ms \"MM/dd/yy\"   :{date.format}}:mmddyy;\n    {.ms \"MM/dd/yyyy\" :{date.format}}:mmddyyyy;\n    {.ms \"hh:mm aa\"   :{date.format}}:timestr;\n\n}:date;\n\n.#? dateunit\\n  static namespace defining units related to dates\n{,\n    [\n        [\"year\" 31536000000]\n        [\"month\" 2628000000]\n        [\"week\" 604800000]\n        [\"day\" 86400000]\n        [\"hour\" 3600000]\n        [\"minute\" 60000]\n        [\"second\" 1000]\n    ]:units;\n\n    units # {u : name conv,\n        u0I:name;\n        u1I:conv;\n        {,\n            1 :__pushself__;\n            {n::num meta, {,n:n} meta :M}:__new__;\n            {.n x +} {, \" dates.$name\":x} .+ :__repr__;\n            {.n conv*}.use[::conv]:ms;\n            {date.__radd__.`~}:__add__;\n            {date.__rsub__.`~}:__sub__;\n        } name:S := ;\n    };\n}:dateunit;\n\n.#? dates\\n  static namespace for date related variables\n{,\n    .# Units\n    dateunit.units # {u : name,\n        u0I:name;\n        \"{dateunit.$name!}:$name\"~\n    };\n\n    .# Week Day Names\n    [\n        \"Sunday\" \"Monday\" \"Tuesday\" \"Wednesday\"\n        \"Thursday\" \"Friday\" \"Saturday\"\n    ]:weekdays;\n    [\"Sun\" \"Mon\" \"Tue\" \"Wed\" \"Thr\" \"Fri\" \"Sat\"]:weekdaysabb;\n\n    .# Month Names\n    [\n        \"January\" \"February\" \"March\" \"April\"\n        \"May\" \"June\" \"July\" \"August\"\n        \"September\" \"October\" \"November\" \"December\"\n    ]:monthnames;\n\n    [\n        \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\"\n        \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n    ]:monthsabb;\n\n}:dates;\n\n{date.now}:now;\n", "std/la.aya": ".# This file is a part of Aya: https://github.com/aya-lang/aya\n\n.# la.aya\n.# Defines linear algebra functions\n\n.# Wrapper functions\n{:{la.mul}}:dot;\n", "std/threading.aya": "struct thread {id}\n\ndef ::new {: thread^,\n    :{thread.new} thread!\n}\n\n.# Create a new thread\ndef thread::new {cls,\n    :{thread.new} thread!\n}\n\n\ndef thread::add_task {block self,\n    .# Add task to thread\n    .#\n    .# aya> {1 1 +} thread.add_task\n    .# aya> {1 1 +} thread +\n\n    block.` self.id :{thread.add_task}\n    self\n}\n\n.# Use sum to easily add multiple tasks to a thread\n.# aya> threading.new :t;\n.# aya> [{1} {2} {3}]: tasks;\n.# t tasks J W\ndef thread::__add__ (thread.add_task.`)\ndef thread::__radd__ {\\+}\n\n\n\ndef thread::wait_for_result {self,\n    .# Join and get result from thread\n    .#\n    .# aya> thread.wait_for_result\n    .# aya> thread .|\n    self.id :{thread.wait_for_result}\n}\n\ndef thread::__abs__ (thread.wait_for_result.`)\n\n\ndef thread::has_unfinished_tasks {self,\n    self.id :{thread.has_unfinished_tasks}\n}\n\n\n\nclass pool\n\ndef pool::__init__ {n_threads::num self : thread^,\n    [] self.:threads_with_tasks;\n    [n_threads,; thread.new] self.:thread_pool;\n}\n\ndef pool::exec { tasks::list finished_callback::block self : finished_threads,\n    .# Loop until no tasks remain\n    {\n        .# For each thread with a task, check if it is ready,\n        .# if it is, get the result and add it back to the pool\n        [] :finished_threads;\n        self.threads_with_tasks :# {thread : res,\n            thread.has_unfinished_tasks ! {\n                thread.wait_for_result finished_callback\n                .#draw_result cvs.show\n                thread finished_threads .B;\n            } ?\n        };\n\n        .# Remove finished threads from threads with tasks\n        self.threads_with_tasks finished_threads :| self.:threads_with_tasks;\n\n        .# Add the finished threads back to the pool\n        self.thread_pool finished_threads J self.:thread_pool;\n\n       .# Add a task to each thread in the pool\n        self.thread_pool :# {thread,\n            tasks E 0 > {\n                tasks B\\; thread.add_task\n                thread self.threads_with_tasks .B;\n            } ?\n        };\n\n        .# Remove threads with tasks from the pool\n        self.thread_pool self.threads_with_tasks :| self.:thread_pool;\n\n        1 :Z\n\n    tasks E 0 > } W\n\n    .# Wait for all remaining tasks\n    self.threads_with_tasks :# {thread : res,\n        thread.wait_for_result finished_callback\n    };\n\n    .# Put everything back in the pool\n    self.threads_with_tasks self.thread_pool J self.:thread_pool;\n    [] self.:threads_with_tasks;\n}\n\n\n\n", "std/plot.aya": "class plot\nclass multiplot\nclass dataset\n\n.# If true, the view command will not open windows\n.# Generally useful is running tests\ndef plot::_supress_windows 0\n\n.# plot\n.#   data::list : list of plot.dataset objects (see plot.dataset)\n.#   title::str : plot title\n.#   bgcolor::color/str : background color\n.#   color_cycle::list : override the default color cycle\n.#   x,y::dict : axis configuration\n.#       gridlines::bool : show axis gridlines\n.#       gridline_color::color/str : axis gridline color\n.#       zeroline::bool : show axis zero line\n.#       visible::bool : draw axis labels\n.#       lim::list : min and max axis limits\n.#       label::str : axis label\n.#   <any value in dataset params will be used as the default value>\n.#       for example, setting stroke to 10 here will make it the default\n.#       for all lines that do not explicitly provide one\ndef plot::__init__ {self,\n    [] self.:data;\n\n    {,} self.:y;\n    {,} self.:x;\n}\n\n\n.# plot.dataset\n.#   x::list : domain data\n.#   y::list : range data\n.#   label::str : name of the dataset\n.#   color::color/str : color of line/shapes\n.#   stroke::num : stroke weight (may be non-integer)\n.#   lines::num (bool) : draw lines between points\n.#   points::num (bool) : draw points\n.#   yclip::list ([min,max]) : y values outside of this range will not\n.#       be rendered, they will create a jump in the graph\ndef dataset::__init__ {x y params self,\n    x self.:x;\n    y self.:y;\n    self params .+ ;\n}\n\n.# Get y as a list\n.# If y is a block, apply it to x and return a list\ndef plot::_get_y {x::list y plot,\n    {\n        (y.` :T ::block =) {\n            x y :y;\n        } (y.` :T ::list =) {\n            .# noop\n        } {\n            \"invalid\" .D\n        }\n    } :?\n    y\n}\n\n.# Add a dataset to the plot\ndef plot::_add_dataset {d::dataset self,\n    d self.data .B ;\n}\n\n.# Generic plot function\n.# Add a new dataset to the plot\ndef plot::plot {x::list y params::dict self : dataset^,\n    x (x y.` self.M._get_y) params dataset! self._add_dataset\n}\n\n.# Adds a new dataset to the plot, formatted as a scatter plot\ndef plot::scatter {x::list y params::dict self : dataset^ d,\n    x (x y.` self.M._get_y) params dataset! :d;\n    0 d.:lines;\n    1 d.:points;\n    d self._add_dataset\n}\n\n.# Show the plot in a window\ndef plot::view {self,\n    self.M._supress_windows ! {\n        \"\" self.:filename;\n        self :{plot.plot}\n    } ?\n\n}\n\n.# Multi-Plot\n.##############\n\ndef multiplot::__init__ {self,\n    [] self.:subplots;\n\n    {,} self.:y;\n    {,} self.:x;\n}\n\ndef multiplot::add {plot self,\n    plot self.subplots.append;\n}\n\ndef multiplot::view {self : plot^,\n    plot._supress_windows ! {\n        \"\" self.:filename;\n        self :{plot.plot}\n    } ?\n}\n\n\n.# Quick Plot Functions\n.########################\n\n.# Create a line plot with default paramaters and x,y as a dataset\ndef ::line {x::list y::list : p plot^,\n    plot! :p;\n    x y {,} p.plot\n    0 p.:legend;\n    p\n}\n\n.# Create a line plot with default paramaters and x,y as a dataset\ndef ::fns {fns::list a::num b::num : x p plot^,\n    plot! :p;\n    [a b 300] .R :x;\n    fns {f, \n        x :& f.` O {, f.`P:label} p.plot\n    } O;\n    1 p.:legend;\n    p\n}\n", "std/missing.aya": "{,} {,\n  ::missing:__type__;\n  {; \"Cannot create instance of missing\" .D}:__new__;\n  {\"missing\"}:__str__:__repr__;\n  {; []}:__range__;\n\n  {;; 0}\n      :__eq__\n      :__lt__:__leq__\n      :__gt__:__geq__;\n\n  {;; missing}\n      :__add__:__radd__\n      :__sub__:__rsub__\n      :__mod__:__rmod__\n      :__and__:__rand__\n      :__or__ :__ror__\n      :__mul__:__rmul__\n      :__div__:__rdiv__\n      :__pow__:__rpow__\n      :__idiv__:__irdiv__;\n\n  {}\n      :__fact__\n      :__negate__\n      :__signnum__\n      :__sin__:__asin__\n      :__cos__:__acos__\n      :__tan__:__atan__\n      :__float__\n      :__random__\n      :__ceil__\n      :__floor__\n      :__log__\n      :__ln__\n      :__exp__\n      :__sqrt__\n      :__abs__;\n\n} :M :missing;\n", "std/enum.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Defines the enum keyword which allows for\n.#  easy creation of enum classes and symbol groups\n\nexport ::enum\n\n{class::sym enums::list : dict meta,\n\n    .# The metatable for each enum member\n    {,\n        class :__type__;\n        1 :__pushself__;\n        {self, \"$(self.__type__:C).$(self.name:C)\"}:__str__:__repr__;\n        {other self,\n            other.__type__ self.__type__ =\n            other.name self.name = &\n        }:__eq__;\n    }:meta;\n\n    .# The enum dict\n    {, class:name }:dict;\n\n    .# Add each element to the enum dict\n    enums # {e,\n        {,e:name} meta :M e dict :D ;\n    };\n\n    .# Create and add the metatable for the enum\n    dict {,\n        1 :__pushself__;\n        ::enum :__type__;\n        {.name:C}:__repr__:__str__;\n    } :M\n\n    .# Assign the name of the enum to the enum class\n    class := ;\n}:_enum_impl;\n\n\n.# enum macro\n\n{ : _enum_impl(_enum_impl.`),\n    { : _enum_impl^ , :&.[0]:S~ \\.[1]~.*:#{:S~} _enum_impl } 2 :`\n}:enum;", "std/socket.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# socket.aya\n.# Defines socket and socket_server types\n\nexport [::socket ::socket_server]\n\nstruct socket {\n    _sock\n}\n\nstruct socket_server {\n    _srv\n}\n\ndef socket_server::accept {self : socket^,\n    self._srv :{socket.accept} socket!\n}\n\ndef socket_server::listen {addr port : socket_server^,\n    addr port :{socket.open_server} socket_server!\n}\n\ndef socket_server::close {self,\n    self._srv :{socket.close}\n}\n\ndef socket_server::port {self,\n    self._srv :{socket.get_port}\n}\n\ndef socket_server::addr {self,\n    self._srv :{socket.get_addr}\n}\n\ndef socket::connect {addr port : socket^,\n    addr port :{socket.open_client} socket!\n}\n\ndef socket::recv {self,\n    self._sock :{socket.recv}\n}\n\ndef socket::port {self,\n    self._sock :{socket.get_port}\n}\n\ndef socket::addr {self,\n    self._sock :{socket.get_addr}\n}\n\ndef socket::send {self,\n    self._sock :{socket.send}\n}\n\ndef socket::println {data self,\n    data P \"\\r\\n\" + self._sock :{socket.send}\n}\n\ndef socket::close {self,\n    self._sock :{socket.close}\n}\n", "std/turtle.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.{\n    turtle\n\n    A simple turtle graphics library\n    The API is modeled after python's built-in turtle library\n\n    Examples:\n        .# Offset nested balls\n        {, 200:width 200:height} turtle!:t\n        10R :# {n, {0.1 t.right n t.fd 2:Z} 100 %} ;\n\n        .# A small colorful star\n        color.colors.red {10\\.hueshift $ t.pencolor 40 t.fd 124 t.right} 36 %\n.}\n\nimport ::canvas\nimport ::color\n\nexport ::turtle\nclass turtle\n\ncolor.colors.white :c_white;\ncolor.colors.black :c_black;\n\n\ndef turtle::__init__ {params::dict self : canvas^ c_black^ c_white^,\n\n    .# Default values\n    {,\n        0:x\n        0:y\n        0:r\n        400:width;\n        300:height;\n        ::deg:units;\n        1 :autodraw;\n        c_white :bg_color;\n        c_black :fg_color;\n        nil :canvas;\n    }\n\n    .# Merge user defined\n    params .+ :params;\n\n    params.x self.:_x;\n    params.y self.:_y;\n    params.r self.:_r;\n\n    params.units [::deg ::degrees].in self.:_use_deg;\n\n    .# Use the provided canvas or generate one?\n    params.canvas nil = {\n        params.width self.:_w;\n        params.height self.:_h;\n        {, self._w:width self._h:height \"Turtle\":name } canvas! self.:_cvs;\n    } {\n        params.canvas self.:_cvs;\n        self._cvs.width self.:_w;\n        self._cvs.height self.:_h;\n    } .?\n\n    .# Draw background\n    params.bg_color self._cvs.set_color\n    0 0 self._cvs.width self._cvs.height self._cvs.fillrect\n\n    params.fg_color self._cvs.set_color\n\n\n    1 self.:_pen_down;\n    params.autodraw self.:_autodraw;\n\n\n}\n\ndef turtle::__repr__ {self,\n    \"turtle: pos=($(self._x), $(self._y)) dir=$(self._r)\"\n}\n\n.#################\n.# Turtle Motion #\n.#################\n\ndef turtle::fd {n self : px py,\n    self._x :px;\n    self._y :py;\n    self._x self._r Mc n * + self.:_x;\n    self._y self._r Ms n * + self.:_y;\n    px py self._step_from\n}\n\ndef turtle::right {amount self,\n    self._r amount self._to_rad + self.:_r;\n}\n\ndef turtle::left {amount self,\n    self._r amount self._to_rad - self.:_r;\n}\n\ndef turtle::goto {x y self : px py,\n    self._x :px;\n    self._y :py;\n    x self.:_x;\n    y self.:_y;\n    px py self._step_from\n}\n\ndef turtle::pos {self,\n    self._x self._y\n}\n\ndef turtle::draw {self,\n    self._cvs.show\n}\n\ndef turtle::close {self,\n    self._cvs.close\n}\n\n.###############\n.# Pen Control #\n.###############\n\ndef turtle::pendown {self,\n    1 self.:_pen_down;\n}\n\ndef turtle::penup {self,\n    0 self.:_pen_down;\n}\n\ndef turtle::isdown {self,\n    self._pen_down\n}\n\ndef turtle::pencolor {c::color self,\n    c self._cvs.set_color\n}\n\n\n.####################\n.# Helper Functions #\n.####################\n\n\n.# This function maps the turtle\n.# coordinate space to the canvas coordinate space\n.# The turtle lives in a coordinate frame where (0,0) is\n.# at the center of the canvas.\ndef turtle::_tf {x y self,\n    x self._w 2/ +\n    y self._h 2/ +\n}\n\n.# Convert the input value to radians if units is degrees\ndef turtle::_to_rad {val self,\n    self._use_deg\n        val :1p1 180 / *\n        val\n    .?\n}\n\n\n.# Callback function for after the turtle steps\n.# Assumes the turtle's position has already been updated\n.# px and py are the turtles previous location\ndef turtle::_step_from {px py self,\n    self._pen_down {\n        px py self._tf\n        self._x self._y self._tf\n        self._cvs.line\n        self._autodraw {\n            self._cvs.show\n        } ?\n    } ?\n}\n\n.#############\n.# Overloads #\n.#############\n\ndef turtle::__rpow__ {self val,\n  val self.fd\n  self\n}\n\n\n.# For testing\n{,\n    100 :width\n    100 :height\n    ::deg :units\n} turtle! :t\n", "std/bitset.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# bitset.aya\n.# Defines bitset type\n\nclass bitset\nexport ::bitset\n\ndef bitset::__new__ {s meta,\n    s :T ::num = {\n        {, s:size 0sL:bits } meta :M\n    } {\n        s meta.fromlist\n    } .?\n}\n\ndef bitset::fromlist {l::list : bitset^,\n    {, lE:size l:bits } bitset :M\n}\n\n\ndef bitset::__str__ { .bits P \"bitset!\" + }\n\ndef bitset::__repr__ (bitset.__str__.`)\n\n\n\n.#? index ::bitset.set\\n  set the bits given by the index to true\n.{ Example:\n    aya> 4 bitset! :b\n    [ 0 0 0 0 ]\n    aya> 1 b.set\n    aya> b\n    [ 0 1 0 0 ]\n    aya> [0 3] b.set\n    aya> b\n    [ 1 1 0 1 ]\n.}\ndef bitset::set {n self,\n    1 self.bits.:[n];\n}\n\n\n.#? index ::bitset.set\\n  set the bits given by the index to false\n.{ Example:\n    aya> [1 0 1 0] bitset! :b\n    [ 1 0 1 0 ]bitset!\n    aya> 0 b.reset\n    aya> b\n    [ 0 0 1 0 ]bitset!\n.}\ndef bitset::reset {n self,\n    0 self.bits.:[n];\n}\n\n.#? ::bitset.__getindex__\\n  get value of bit at the given index\n.{ Example:\n    aya> [1 0 1 0] bitset! :b\n    [ 1 0 1 0 ]bitset!\n    aya> b.[0]\n    1\n    aya> b.[0 2]\n    [ 1 1 ]\n.}\ndef bitset::__getindex__ {n self,\n    self.bits.[n]\n}\n\n\n.#? ::bitset.count\\n  return the number of true bits in the set\n.{ Example:\n    aya> [0 1 0 1] bitset! .count\n    2\n    aya> [1 1 1 1] bitset! .count\n    4\n.}\ndef bitset::count { .bits W }\n\n.#? ::bitset.__signum__\\n  not each bit\n.{ Example:\n    aya> [1 0 1 0] bitset! .!\n    [ 0 1 0 1 ]bitset!\n.}\ndef bitset::__signum__ {self,\n    self.bits #! self.M.fromlist\n}\n\n\n.#? ::bitset ::bitset.__or__\\n  or two bitsets\n.{ Example:\n    aya> [0 0 0 1] bitset! [1 1 0 0] bitset! |\n    [ 1 1 0 1 ]bitset!\n.}\ndef bitset::__or__ {other self,\n    other.bits self.bits {|}.&\n    self.M.fromlist\n}\n\n\n.#? ::bitset ::bitset.__and__\\n  and two bits\n.{ Example:\n    aya> [1 0 0 1] bitset! [1 1 0 0] bitset! &\n    [ 1 0 0 0 ]bitset!\n.}\ndef bitset::__and__ {other self,\n    other.bits self.bits {&}.&\n    self.M.fromlist\n}\n\n\n.#? ::bitset.__len__\\n  the size of the bitset\n.{ Example:\n    aya> [1 1 0 0] bitset! E\n    4\n    aya> [1 1 0 0 1 1 0 0] bitset! E\n    8\n.}\ndef bitset::__len__ { .bits E }\n", "std/mp.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Metaprogramming utilities\n\nmodule mp\nexport ::mp\n\n.#? ::list mp.capture_vars\\n  given a list of symbols, return a dict with each symbol and\ndef mp::capture_vars ( {}.M._capture_vars.` )\n\n\n.#? ::list mp.merge\\n  Convert a list of blocks into a single block\ndef mp::merge {\n    #.op .*\n}\n\n\n\n", "std/csv.aya": "module csv\nexport ::csv\n\ndef csv::parse {dlm : rgx,\n    \"(?<=^|$dlm)(\\\"(?:[^\\\"]|\\\"\\\")*\\\"|[^$dlm]*)\" :rgx; .#\"\n    '\\n' S :# {line,\n        line.trim :line;\n        line rgx & :#{.trim .rmquote .!}\n    }\n}\n\ndef csv::open {f : csv^,\n    fP G \",\" csv.parse\n}\n\ndef csv::read { arg : csv^ ,\n    {\n        (arg :T ::str =) {\n            .# convert to dict\n            {, arg :filename }\n        } (arg :T ::dict =) {\n            arg\n        } {\n            \"csv.read: Unsupported arg type $(arg:T). Must be ::str or ::dict\" .D\n        }\n    } :?\n\n    csv._read_kw\n}\n\ndef csv::_read_kw {kwargs::dict : csv^\n                                clabel(1)\n                                rlabel(nil)\n                                filename(nil)\n                                csv_str(nil)\n                                dlm(\",\")\n                                data\n                                colnames(nil)\n                                rownames(nil),\n    kwargs ~\n\n    (csv_str nil = filename nil = &) {\"csv.read: Must provide either filename or csv_str\" .D} ?\n\n    .# Open the file and read into data\n    filename nil =! {filenameP G :csv_str;} ?\n\n    csv_str dlm csv.parse :data;\n\n    .# Attempt to auto-detect rlabel if it is not specified\n    rlabel nil = {\n        data.[0].[0] \"\" = {\n            1 :rlabel;\n        } {\n            0 :rlabel;\n        } .?\n    } ?\n\n    .# CSV has column headers\n    clabel {\n        data V :colnames; ;\n        .# If there are row labels, the first entry is for the index colum\n        rlabel {colnamesV;:colnames;} ?\n    } ?\n\n    rlabel {\n        data :#{V\\;} :rownames;\n    } ?\n\n    {,\n        data:data\n        colnames:colnames\n        rownames:rownames\n    }\n}\n\n.#? list sep na csv.dumps\\n  convert a 2d list to a csv string\ndef csv::dumps {list sep na,\n    list :# {\n        :#{\n            .# If it is na, make it emptystr\n            :& na = {;\"\"} ?\n            .# If it is a string, surround with quotes\n            :& P \\ ::str :@ {\"\\\"\"+ \"\\\"\"\\+} ?\n        }\n        sep %\n    } \"\\n\" %\n}\n\n\n", "std/math.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# math.aya\n.# Essential math functions for Aya\n\n.# Export all variables\nexportall\n\n\n.#############\n.# Constants #\n.#############\n\n\n:1c :e;    .#? euler: euler's constant e\n:0c :pi;       .#? pi:  constant \\{pi}\n:4c :nan;      .#? nan:  not a number double literal\n:5c :inf;      .#? inf:  infinity double literal\n:6c :minf;     .#? minf:  minus infinity double literal\n:1r4:fourth;   .# \u00bc\n:1r2:half;     .# \u00bd\n\n.#? phi: golden ratio (constant)\n.# Compute phi using 2 adjacent fib numbers\n[1000 $B, 1\\0{$@+}@%;]$1I\\0I/\n:phi;\n\n\n\n\n.########################\n.# Vectorized Functions #\n.########################\n\n\n{.|}:abs;           .#? N abs\\n  absolute value\n{1 3/^}:cbrt;       .#? N cbrt\\n  cube root\n{./}:ceil;          .#? N ceil\\n  ceiling\n{pi*180/}:deg;      .#? N deg\\n  convert deg to rad (180\u00b0 => 3.14..)\n{180*pi/}:rad;      .#? N rad\\n  convert rad to deg (pi rad => 180)\n{Me}:exp;           .#? N exp\\n  exp(x)\n{M!}:fact;          .#? N fact\\n  factorial\n{.\\}:floor;         .#? N floor\\n  floor\n{ML2ML/}:lg;        .#? N lg\\n  base-2 log\n{Ml}:ln;            .#? N ln\\n  natural log\n{ML}:log;           .#? N log\\n  base-10 log\n{:%}:mod;            .#? N mod\\n  modulo\n{Mp}:primes;        .#? N primes\\n  returns a list containing the primes up to and including N\n{.!}:signnum;       .#? N signnum \\n  returns the sign of a number (1,0,-1)\n{.^}:sqrt;          .#? N sqrt\\n  square root\n{.%}:div;           .#? <NN> div\\n  integer division\n{%}:rem;            .#? <NN> rem\\n  remainder after division\n{PE}:numofdigits;   .#? N numofdignts\\n  number of digits in N\n\n.# Binary vectorized functions\n{2^\\2^+.^}:hypot;   .#? N hypot\\n  hypotenuse function\n{ML\\ML\\/}:logn;     .#? N logn\\n  base-n log\\n ex: log base 6 of 10 written as (10 6logn)\n\n\n.###################\n.# List Operations #\n.###################\n\n{:&2^W.^/}:normal;   .#? L<N> normal\\n  compute the normal vector of the given list\n{{*}/}:product;     .#? L product\\n  product of a list\n{*W}:vdot;           .#? LL vdot\\n  vdot product of two vectors\n{2^W.^}:norm;       .#? L norm\\n compute the vector norm\n\n\n.#? NN lcm\\n least common multiple of two numbers or a list of numbers\n{:& :T ::num = {.-}{{.-}/} .?}:lcm;\n\n.#? NN gcd \\n  greatest common divisor of 2 numbers or a list of numbers\n{:& :T ::num = {.+}{{.+}/} .?}:gcd;\n\n.#? L<N> cumsum\\n  cumulative summation of a list\n.{\n{list : sum outlist,\n    .# Allocate output list\n    0 listE L :outlist;\n\n    list.irange # {i,\n      list iI sum + : sum;\n      sum outlist i D\n    };\n\n    outlist\n}:cumsum;\n.}\n{l,lER:#{l\\.<W}}:cumsum;\n\n\n\n.#? L<N> cumprod\\n  cumulative product of a list\n.{\n{list : prod outlist,\n    .# Initialize prod\n    1:prod;\n\n    .# Allocate output list\n    0 listE L :outlist;\n\n    list.irange # {i,\n        list iI prod * : prod;\n        prod outlist i D\n    };\n\n  outlist\n}:cumprod;\n.}\n{l,lER:#{l\\.<{*}/}}:cumprod;\n\n\n\n\n\n\n.################\n.# Trigonometry #\n.################\n\n{Ms}:sin;                   .#? N sin \\n  sine\n{Mc}:cos;                   .#? N cos \\n  cosine\n{Mt}:tan;                   .#? N tan \\n  tangent\n{Ms1\\/}:csc;                .#? N csc \\n  cosecant\n{Mc1\\/}:sec;                .#? N sec \\n  secant\n{Mt1\\/}:cot;                .#? N cot \\n  cotangent\n\n{MS}:asin;                  .#? N asin \\n  inverse sine\n{MC}:acos;                  .#? N acos \\n  inverse cosine\n{MT}:atan;                  .#? N atan \\n  inverse tangent\n{1\\/MS}:acsc;               .#? N acsc \\n  inverse cosecant\n{1\\/MC}:asec;               .#? N asec \\n  inverse secant\n{1\\/MT}:acot;               .#? N acot \\n  inverse cotangent\n\n{$Me\\TMe- 2/}:sinh;          .#? N sinh \\n  hyperbolic sine\n{$Me\\TMe+2/}:cosh;          .#? N cosh \\n  hyperbolic cosine\n[{$} sinh.` {\\}\n     cosh.` {/}].* :tanh;   .#? N tanh \\n  hyperbolic tangent\n[sinh.` {1\\/}].* :csch;     .#? N csch \\n  hyperbolic cosecant\n[cosh.` {1\\/}].* :sech;     .#? N sech \\n  hyperbolic secant\n[tanh.` {1\\/}].* :coth;     .#? N coth \\n  hyperbolic cotangent\n\n{$2^1+.^+Ml}:asinh;             .#? N asinh \\n  inverse hyperbolic sine\n{$$1-.^\\1+.^*+Ml}:acosh;        .#? N acosh \\n  inverse hyperbolic cosine\n{$1\\+Ml\\1\\-Ml- .5*}:atanh;      .#? N atanh \\n  inverse hyperbolic tangent\n{$1\\/\\2^1\\/1+.^+Ml}:acsch;      .#? N acsch \\n  inverse hyperbolic cosecant\n{1\\/$$1+.^\\1-.^*+Ml}:asech;     .#? N asech \\n  inverse hyperbolic secant\n{1\\/$1\\-Ml\\1+Ml\\- .5*}:acoth;   .#? N acoth \\n  inverse hyperbolic cotangent\n\n\n\n.#? ::list makepoly\\n  generate a polynomial function with the given coefficients\n.{ Examples:\n    aya> [1 0 4 5] makepoly :f\n    {[ 3 2 1 0 ] ^ [ 1 0 4 -5 ] * W}\n    aya> 5 f\n    140\n    aya> [2 0] makepoly :double\n    {[ 1 0 ] ^ [ 2 0 ] * W}\n    aya> [4,double]\n    [ 2 4 6 8 ]\n.}\n.# {.E .R U {2, :c ; :p} {p ^ c * W} \\ .+}:makepoly;\n{ [1| .E .R U {^} \\ {*W} ].* }:makepoly;\n\n\n\n.#############################\n.# Additional Math Functions #\n.#############################\n\n.# BASE\n\n{2 10  .&}:unbit;   .#? L unbit \\n  convert a list of bits to a number\n{10 2  .&}:bits;    .#? N bits \\n  convert a positive number to a list of bits\n{10 16 .&}:hex;    .#? N hex\\n  convert an int into a hex string\n{16 10 .&}:unhex;  .#? S unhex\\n  convert a hex string to an int\n\n\n\n.# COMBINATORICS\n\n{G}:isprime;                   .#? N isprime \\n  tests a number for primality\n{n r, nM! n r-M!/}:npr;        .#? NN npr\\n  permutations\n{n r, nM! n r- M!/ rM!/}:bin;  .#? NN bin\\n binomial (combinations)\n\n.#? N divisors \\n  returns a list of the numbers factors\n{n, [1 n,, n\\:%0=]}:divisors;\n\n.#? N factors\\n  compute a number's prime factors\n.# golf: {n,{2to(nV){n\\:%0=}.NI$n\\/f:J}{n}nGn2<|?}:f;\n{n,\n    .# is the number prime\n    nG n2< |\n\n    .# If the number is prime, return it\n    {[n]}\n\n    .# If the number is not prime, find the\n    .#   next factor\n    {\n        .# Range from 2..ceil(sqrt(n))\n        [2nV.^./]R\n\n        .# Find the next factor\n        {n\\:%0=}.N\n\n        .# Append this factor to the list of\n        .#   factors recursively\n        I $n\\/ factors :J\n    }\n\n    .?\n}:factors;\n\n.# Generate a normally distributed random number using the Box-Muller transform\n{.Q Ml -2 * .^ :2p .Q * Mc * }:randnorm;\n", "std/versionstr.aya": "class versionstr\nexport [::versionstr ::v]\n\ndef versionstr::__init__ {maj min pat self,\n    majP self.:major;\n    minP self.:minor;\n    pat \"\" = 0 pat .? P self.:patch;\n}\n\ndef ::v { {\n    ~ '.| 3.< ~ versionstr!\n} 0:` }\n\ndef versionstr::__str__ {self,\n    \"v\\\"$(self.major).$(self.minor).$(self.patch)\\\"\"\n}\n\ndef versionstr::__repr__ (versionstr.__str__.`)\n\n\n", "std/sys.aya": "from ::io import ::path\n\nmodule sys\nexport ::sys\n\ndef sys::args :{sys.args}\n\n\n.#? sys.iswindows\\n  returns true if system is windows\ndef sys::iswindows {:9s\"\\\\\"=}\n\n\n.# ::str sys.cd\\n  set working directory\ndef sys::cd {dirname : path^,\n    dirname\n    .# If it is a string, conv to path\n    dirname :T ::str = { path! } ?\n    P :{sys.cd}\n}\n\n\n.#? ::str sys.mkdir\\n  create a new directory\ndef sys::mkdir {dir,\n    dir P :{sys.mkdir}\n}\n\n\ndef sys::readdir {dir,\n    dir P :dir;\n    dir \"\" = {\".\" :dir;} ?\n    dir :{sys.readdir}\n}\n\n", "std/asciiart.aya": ".{\n    asciiart\n\n    A small toy library for drawing ascii art\n\n    asciiart makes heavy use of operator overloading to allow programs\n    to be as short and concise as possible.\n\n    Examples:\n\n      - A simple train:\n\n        aya> \" 6_`|6 |` ()--()\"_ 3L\"  ~\"_T*\n        asciiart:\n         ______   ______   ______\n        |      | |      | |      |\n         ()--() ~ ()--() ~ ()--()\n\n\n      - Order N Serpinski triangle:\n\n        aya> 3 \"##`#\"_\\L{I}/\n        asciiart:\n        ########\n        # # # #\n        ##  ##\n        #   #\n        ####\n        # #\n        ##\n        #\n\nhttps://codegolf.stackexchange.com/questions/101684/all-aboard-the-ascii-train\n\"hello\"\n({\n.E\"3 3_`  | # |`  |3_|`_|5\\\"|\"_ \"\\\"`-0-0-'\"/\\L\\{'#\\JI}.&W\"4 o O O`3 o`  TW__[O]` {6=|\" _\"./o--000'\"/\\+\n})\n.}\n\nclass asciiart\nexport [::asciiart ::_]\n\ndef asciiart::__init__ {str self,\n    str :T ::str = {\n        [str] self.:list ;\n    } {\n        .# list\n        .# Make sure all are at least as long as the longest\n        str :&#E .max #.< :str ;\n        str self.:list ;\n    } .?\n}\n\ndef asciiart::__eq__ {self c::char,\n    self.list :# { :# {; c}} self.M!\n}\n\ndef asciiart::__str__ {self,\n    self.list \"\\n\" %\n}\n\ndef asciiart::__repr__ {self,\n    \"asciiart:\\n$(self.__str__)\\n\"\n}\n\n\ndef asciiart::__negate__ {self,\n    self.list.T self.M!\n}\n\n\n.{  Transpose\n    Example:\n\n    aya> \"3#`.##`..#\"_ $ T\n    asciiart:\n    ###\n    .##\n    ..#\n     asciiart:\n    #..\n    ##.\n    ###\n.}\ndef asciiart::__negate__ {self,\n    self.list.T self.M!\n}\n\n\n.{ Example:\n\n    aya> \"3#`3.`#..\"_ $ +\n    asciiart:\n    ######\n    ......\n    #..#..\n\n    aya> \"3#`3.`#..\"_ '~ +\n    asciiart:\n    ###~\n    ...~\n    #..~\n\n    aya> \"3#`3.`#..\"_ \")>\" +\n    asciiart:\n    ###)>\n    ...)>\n    #..)>\n\n    aya> [\"3#`3.`#..\"_ $ '~\\] W\n    asciiart:\n    ###~###\n    ...~...\n    #..~#..\n.}\ndef asciiart::__add__ {other self,\n    other :T ::char = other :T ::str = | {\n        self.list #{other \\+} self.M!\n    } {\n        other.list .T self.list.T :J .T self.M!\n    } .?\n}\n\n\ndef asciiart::__radd__ {self other,\n    self.list #{other +} self.M!\n}\n\n\ndef asciiart::w {self,\n    self.list.T E\n}\n\ndef asciiart::h {self,\n    self.list E\n}\n\n.{ Horizontal stack\n   Example:\n    aya> \"3#`3.`#..\"_ $ /\n    asciiart:\n    ###\n    ...\n    #..\n    ###\n    ...\n    #..\n.}\ndef asciiart::__div__ {other self,\n    other.list $\\; self.list $\\; :J self.M!\n}\n\ndef asciiart::__rdiv__ {self other,\n    self other self.M! /\n}\n\n\n.{ Reverse along vertical axis\n   Example:\n    aya> \"3#`3.`#..\"_ $ U\n    asciiart:\n    ###\n    ...\n    #..\n     asciiart:\n    ###\n    ...\n    ..#\n.}\ndef asciiart::__reverse__ {self$,\n    self.list :#{U};\n    self\n}\n\ndef asciiart::__dec__ {self$,\n    self.list U ;\n    self\n}\n\ndef asciiart::join {list self,\n    list :#{self} B; W\n}\n\ndef asciiart::__rpow__ {self num,\n    self {self +} numV %\n}\n\n.{ Example:\n    aya>  \"aba`bad\" _ '# I\n    ::char\n    asciiart:\n    ###\n    ###\n\n    aya>  \"aba`bad\" _ \"a#\" I\n    ::str\n    asciiart:\n    #b#\n    b#d\n\n    aya> \"# ` #\"_ \"abc`def\"_ I\n    asciiart:\n    abc\n    def\n       abc\n       def\n.}\ndef asciiart::__getindex__ {index self,\n    {\n        (index :T ::str =) {\n            index self.replace\n        } (index :T ::char =) {\n            index self.fill\n        } (index :T ::asciiart =) {\n            index self.replace_aa\n        } {\n            \"asciiart::__getindex__ invalid index type\" .D\n        }\n    } :?\n}\n\n.{ Example:\n    aya> '@ \"abc`def\" _ .fill\n    asciiart:\n    @@@\n    @@@\n\n    aya> \"#\" \"abc`def\" _ .fill\n    asciiart:\n    ###\n    ###\n.}\n\ndef asciiart::fill {c self,\n    c :T ::str = {c.[0] :c;} ?\n    self.list :# { :# {; c}} self.M!\n}\n\n\n.{ Example:\n    aya> \"#-\" \"###`# ` # \"_ .replace\n    asciiart:\n    ---\n    -\n     -\n\n    aya> \"###`***\" \"###`# ` # \"_ .replace\n    asciiart:\n    ***\n    #\n     #\n.}\ndef asciiart::replace {s::str self,\n    s '` S .E1={~}? :s ;\n    s V:from ; V:to ; ;\n    self.list :# {from to .&}\n    self.M!\n}\n\n.{ Example:\n    aya> \"3#`# #`3#\"_\n    asciiart:\n    ###\n    # #\n    ###\n\n    aya> \"3#`# #`3#\"_ $.replace_aa\n    asciiart:\n    #########\n    # ## ## #\n    #########\n    ###   ###\n    # #   # #\n    ###   ###\n    #########\n    # ## ## #\n    #########\n.}\ndef asciiart::replace_aa {a::asciiart self : l,\n    a $ ' I \\ J :l;    .# List of aa and empty version of aa\n    self.list ' #.= #! .# Mask of filled/empty\n    :#{\n        :#{ l \\ I }    .# Use the mask to index into the list\n        W              .# Concat each aa in the row\n    } {/}/             .# Concat each row\n}\n\ndef asciiart::rle {s asciiart,\n    s $ \"\\\\d+\" S \\ \"\\\\d+\" &  .# Split into lists of string sections and runs\n                            .# Ex: \"3a 4b\" => [\"\" \"a \" \"b\"] [\"3\" \"4\"]\n    .E 0 = {\n        ;;s                 .# If no rle to do, just return the string\n    } {                     .# There is rle to do, do this block\n        #.!                 .# convert strings to nums => [3 4]\n        \\V@@                .# Remove the leading string and rearrange\n        {\n            V               .# pop the charachter to repeat\n            @L              .# repeat the character\n            \\+              .# join with original string\n        }\n        .&                  .# Apply the above block to each pair in the list\n        W+                  .# Combine everything\n    } .?\n}\n\n\n\n\n\n[ \"00000\" \"0   0\" \"00000\" ] asciiart!T :o;\n[ \"EEEEE\" \"E E E\" \"E   E\" ] asciiart!T :e;\n[ \"T    \" \"TTTTT\" \"T    \" ] asciiart!T :t;\n[ \"GGGGG\" \"G G G\" \"G GGG\" ] asciiart!T :g;\n\nasciiart:aa;\n\n{asciiart.rle '` S asciiart!}:_;\n\n.{ Example:\n    Generate a Sierpinski carpet:\n    \"3#`# #`3#\"_$I$I\n    .. or triangle\n    \"##` #\"_ $I$I\n\n    \".:.` .\"_$I$I\n\n    \"##`#\"_$I $U\\+ $V\\/ $I\n.}\n", "std/terminal.aya": "import ::color\n\nmodule terminal\nexport ::terminal\n\ndef terminal::fg (color.colors.white)\ndef terminal::bg (color.colors.black)\n\ndef terminal::clear {\"\\{x1b}[2J\".P}\ndef terminal::clearline {\"\\{x1b}[1:J\\{x1b}[1G\".P}\n\ndef terminal::_setfgstr {c::color, \"\\{x1b}[38;2;$(c.r);$(c.g);$(c.b)m\" }\ndef terminal::_setbgstr {c::color, \"\\{x1b}[48;2;$(c.r);$(c.g);$(c.b)m\" }\n\ndef terminal::setfg {c::color : terminal^,\n    c terminal.:fg;\n    c terminal._setfgstr .P\n}\n\ndef terminal::setbg {c::color : terminal^,\n    c terminal.:bg;\n    c terminal._setbgstr .P\n}\n\ndef terminal::bold      { \"\\{x1b}[1m\" \"\\{x1b}[22m\" .? .P}\ndef terminal::italic    { \"\\{x1b}[3m\" \"\\{x1b}[23m\" .? .P}\ndef terminal::underline { \"\\{x1b}[4m\" \"\\{x1b}[24m\" .? .P}\ndef terminal::strike    { \"\\{x1b}[9m\" \"\\{x1b}[29m\" .? .P}\n\ndef terminal::reset_font {: terminal^ ,\n    0 terminal.bold\n    0 terminal.italic\n    0 terminal.underline\n    0 terminal.strike\n}\n\ndef terminal::reset_color {: color^ terminal^ ,\n    color.colors.white terminal.setfg\n    color.colors.black terminal.setbg\n}\n\ndef terminal::replcolor {c::color : color^ terminal^ ,\n    [c terminal._setfgstr\n     \"aya> \"\n     color.colors.white terminal._setfgstr]W\n    :{sys.alterprompt}\n}\n\ndef terminal::print_color {value c::color : terminal^ prev_fg,\n    terminal.fg :prev_fg;\n    c terminal.setfg\n    value P .P\n    prev_fg terminal.setfg\n}\n\ndef terminal::println_color {value c::color : terminal^,\n    value c terminal.print_color\n    \"\" :P\n}\n", "std/color.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# colors.aya\n.# Defines both color and colors types\n\n.{? class: color\n    A module for manipulating and printing colors in Aya\n.}\nclass color\nexport ::color\n\n\n.#\n.# Constructors\n.#\n\ndef color::__init__ {r::num g::num b::num self,\n    [[r g b], .round 0 255 .clip] ~\n    self .:b .:g .:r ;\n    1.0 self.:a;\n}\n\n\ndef color::newhex { color ,\n    0 dot_i '#= {V;} ? .# Strip leading '# if it exists\n    16 2 .& 24 .> [3 8] L #{2 10 .&} ~ color!\n}\n\n\ndef color::newhsv { color,\n    color.hsvtorgb~ color!\n}\n\ndef color::fromstr { s::str color,\n    s :{color.fromstr} color.fromdict\n}\n\ndef color::fromdict { d::dict color ,\n    d.r d.g d.b color!\n}\n\n\n.#\n.# Overloads\n.#\n\ndef color::__repr__ {self,\n    \"($(self.r) $(self.g) $(self.b)) color!\"\n}\n\n\ndef color::__str__ {self,\n    \"($(self.r) $(self.g) $(self.b)) color!\"\n}\n\n\n.#\n.# Math\n.#\n\n.#? ::color ::color *\\n  multiply two colors\ndef color::__mul__ {other self\n    other.rgbf self.rgbf * 255* ~ self.M!\n}\n\n\n.# ::color N *\\n  multiply a color by a value\ndef color::__rmul__ {self n,\n    self.rgbf n * 255* :#{0 255 .clip} ~ self.M!\n}\n\n\n.#\n.# Conversions\n.#\n\n.#? ::color.rgbf\\n  return a list of RGB values represented as floats from 0.0 to 1.0\ndef color::rgbf {self, [self.r self.g self.b] 255 / }\n\n\n.#? ::color.rgb\\n  return a list containing red, green, and blue values respectively\ndef color::rgb {self, [self.r self.g self.b]}\n\n\n.#? ::color.hex\\n  return a hexadecimal string representation of the color\ndef color::hex {.rgb #{10 16 .& 2 '0 @.lpad}W}\n\n\n.#? ::color.hsv\\n  return a list containing hue, sat, and val respectively\ndef color::hsv {self, self.rgb255/~ self.M.rgbtohsv}\n\n\n.#\n.# Interpolation\n.#\n\n.#? ::num ::color ::color.grad\\n  creates a gradient of rgb lists from color1 to color2\ndef color::grad {n::num begin::color self,\n    [ [begin.rgb self.rgb, [2| n] .R .\\]~, self.M!]\n}\n\n.#? ::color ::color color.mid\\n  returns the color in between color1 and color2 using rgb\ndef color::mid {3@@\\.grad 1I}\n\n\n.#? [::color] N color.multigrad\\n  compute a linear gradient with resolution N between each color\ndef color::multigrad {l n,\n    [l {a b, n a b .grad B} / ; ].F\n}\n\n.#? N ::color.hueshift\\n  shift hue by N degrees\ndef color::hueshift {n self,\n    self.hsv $\\; V n + 360 :% \\J ~ self.M.newhsv\n}\n\n\n.#\n.# Static conversion utilities\n.#\n\n.#? NNN color.hsvtorgb\\n  convert h s v (0-360,0-1,0-1) color to hsv\ndef color::hsvtorgb {h s v color : hi p q t ff,\n    .# no saturation, just greyscale\n    s 0 = {\n        [v v v]\n    } {\n        .# Compute hue index\n        .# floor -> mod 360 -> /60 (hh) -> floor (hi)\n        h 360 :% 60 /:hh;\n        hh .\\ :hi;\n\n        hh hi - :ff; .# fractional part\n\n        v 1 s - * :p;\n        v 1 s ff * - * :q;\n        v 1 s 1 ff - * - * :t;\n\n        [\n            [v t p]\n            [q v p]\n            [p v t]\n            [p q v]\n            [t p v]\n            [v p q]\n        ] hi I\n    } .?\n\n    255* :#{.round}\n}\n\n\n.#? NNN color.rgbtohsv\\n  convert r g b color to hsv\\n  r,g,b values are from 0 to 1\ndef color::rgbtohsv {r g b color : h s v delta maxv minv,\n    [r g b].min:minv;\n    [r g b].max:maxv;\n    maxv:v;\n    maxv minv-:delta;\n\n    maxv 0 =! {\n        r maxv = {\n            g b- delta/\n        } {\n            g maxv = {\n                b r- delta/ 2+\n            } {\n                r g- delta/ 4+\n            } .?\n        } .? 60* :h;\n\n        h 0< {h 360+:h;} ?\n\n        delta maxv/:s;\n    } {\n        0:s;\n        -1:h;\n    } .?\n    [h s v]\n}\n\n\n.{? module: colors\n    The colors module defines several color objects. For example:\n      colors.red\n      colors.aqua\n      colors.raspberry\n.}\nmodule colors\n\n{,\n    :{color.name_list} :# {color_name : color_dict,\n        color_name :{color.fromstr} :color_dict;\n        color_dict.r color_dict.g color_dict.b color! color_name :=\n    }\n}:named_colors;\n\n.# Add all named colors to the colors module\ncolors named_colors .+\n\n72  72  68  color! colors.:fg;    .# Aya GUI foreground color\n39  40  34  color! colors.:bg;    .# Aya GUI background color\n\ndef colors::Q {\n    ;255Q 255Q 255Q color!\n}\n\n.# Add the colors module as a submodule of color\ndef color::colors colors\n", "std/shell.aya": ".# Shell-like commands for Aya\n\nimport ::sys\nimport ::io\nimport ::terminal\n\nstruct shellresult {value}\n\ndef shellresult::__repr__ {self,\n    self.value\n}\n\ndef shellresult::lines {self,\n    self.value '\\n' S\n}\n\n\nmodule shell_impl\n\ndef shell_impl::grep {res::shellresult rgx::str : shellresult^ ,\n    res.lines {rgx &E0>} I\n    \"\\n\" % shellresult!\n}\n\ndef shell_impl::cat {filename::str : shellresult^ ,\n    filename G shellresult!\n}\n\ndef shell_impl::echo {data::str : shellresult^ ,\n    data shellresult!\n}\n\n\n.#? ls\\n  print a list of files in the working dir\ndef ::ls {: shellresult^ ,\n    :{sys.wd} :{sys.readdir}\n    .E 0 = {\n        ; \"  <no files>\"\n    } {\n        C \"\\n\" %\n    } .?\n\n    shellresult!\n}\n\n\n.#? pwd\\n  print working directory\ndef ::pwd {: path^ , path.working:P}\n\n\n.#? cd dir\\n  change directory\ndef ::cd {{sys.cd} 0:`}\n\n\n.#? mkdir S\\n  create a new directory\ndef ::mkdir { {sys.mkdir} 0 :` }\n\n\n.# def ::echo ({(4 hold)x (2 hold)~} {, shell_impl.echo.` :x } .+)\n\n.#? echo S\\n  print a string to the console\ndef ::echo {: shell_impl^,  \n    {: shell_impl^, ~ shell_impl.echo } 0 :`\n}\n\n.#? cat S\\n  print a file to the console\ndef ::cat {: shell_impl^, \n    {: shell_impl^, ~ shell_impl.cat} 0 :`\n}\n\ndef ::grep {: shell_impl^, \n    {: shell_impl^, ~ shell_impl.grep} 0 :`\n}\n\n\ndef ::touch { {s::str, \"\" s 1.G} 0 :` }\n\ndef ::clear {:terminal^, terminal.clear}\n\n\ndef (__aya__.interpreter)::shell {str : cmd args,\n    str ' N $ 0 :> {\n        ;; str~\n    } {\n        Mu trim :args; :cmd;\n        cmd~ args\n    } .?\n}\n\nexport [\n    ::sys\n    ::shell_impl\n\n    ::ls\n    ::pwd\n    ::cd\n    ::mkdir\n    ::echo\n    ::cat\n    ::grep\n    ::touch\n    ::clear\n]\n\n", "std/docstr.aya": "{f: argtypes args d,\n    {,}:d;\n    f.`.M W\n    args :# {k,\n        k :C argtypes.[k] \"\" arg! k d :D\n    };\n    d\n}:arginfo;\n\n\n\nclass docstr\n\ndef docstr::__init__ {name string::str self,\n    .# If single item in a list, unwrap the list\n    name :T ::list = {\n        name E 1 = {\n            name.[0] :item;\n        } ?\n    } ?\n\n    {\n        .# If list, use module and name\n        name :T ::list = {\n            name.[0] :module;\n            name.[1] :id;\n        } {\n            nil :module;\n            name :id;\n        } .?\n\n        id :T ::sym = \"\" assert\n    } {err,\n        err :P\n        \"docstr name must be either a list containing a module and a symbol OR a single symbol\" .D\n    } .K\n\n    module self.:_module;\n    id self.:_name;\n    string self.:_full_str;\n\n    {,} self.:sections;\n    { self._parse self.:sections; } {err, \"Error parsing docstr:\\n$err\" .D} .K\n\n    {,} self.:_args;\n    self.sections ::args H {\n        self._parseargs self.:_args;\n    } ?\n}\n\ndef docstr::_parse {self : m(\"@.+:\\n\") d keys vals,\n    self._full_str m & #{.trim B; V;} \"desc\" \\J :keys;\n    self._full_str \"@.+:\\n\" S :# {.trim.lines :# {.trim\"\\n\"+}W.trim}:vals;\n\n    {,}:sections;\n    vals keys {sections :D} .&;\n\n    sections\n}\n\n.# Inner class\ndocstr {, class arg} .+;\n\ndef (docstr.arg)::__init__ {name desc self,\n    name.[0] ': = self.:is_stack_arg;\n\n    self.is_stack_arg {\n        \"-\"     self.:name;\n        name :S self.:type;\n    } {\n        name    self.:name;\n        ::any   self.:type;\n    } .?\n\n    desc.trim self.:desc;\n}\n\ndef (docstr.arg)::__repr__ {self : n l,\n    0 self.show\n}\n\ndef (docstr.arg)::show {margin self : n l pad,\n    self.is_stack_arg {\n        \"$(self.type): \"\n    } {\n        self.type ::any = {\n            \"$(self.name): \"\n        } {\n            \"$(self.name) ($(self.type)): \"\n        } .?\n    } .?\n\n    .E :n;\n    \" \" margin LW :pad;\n    self.desc.lines :#{\n        \" \"nLW\\+\"\\n\"+ pad\\+\n    }W.trim + pad \\+\n}\n\ndef docstr::_parseargs {self : matcher(\"(?m)^(:{2}|)[a-z]+:\"),\n    .# Names\n    self.sections.args matcher & :#{B;}\n    .# Desc\n    self.sections.args matcher S V;\n    .# Create list of arg objects\n    {J}.& :# {~ self.M.arg!}\n}\n\ndef docstr::owner {self,\n    self._module nil = {\n        {\n            self._name ~\n        } {;\n            \"docstr owner ($(self._name)) is not defined\" .D\n        } .K\n    } {\n        {\n            self._module self._name I\n        } {;\n            \"docstr owner ($(self._module_name).$(self._name:C)) is not defined\" .D\n        } .K\n    } .?\n}\n\n\ndef docstr::_getargtypes {self : at f,\n    .# Get arg types from block\n    self.owner:f;\n\n    f.` :T ::block = {\n        f.`.M.argtypes:at;\n        .# If the arg is not a stack arg, copy over its type\n        self._args :# {a,\n            a.is_stack_arg! {\n                {\n                    at.[a.name] a.:type;\n                } {err,\n                    \"[warning] in docstr: block does not have arg ::$(a.name)\":P\n                    self._full_str :P\n                } .K\n            } ?\n        };\n    } ?\n}\n\ndef docstr::finalize {self,\n    self._getargtypes\n}\n\ndef docstr::_module_name {self,\n    .# Try to get the name of the module\n    self._module ::__type__ H {\n        self._module.__type__ :C\n    } {\n        \"<module>\"\n    } .?\n}\n\ndef docstr::_get_name {self,\n    self._module ::__type__ H {\n        self._module.__type__ :C \".\" self._name :C ++\n    } {\n        self._name :C\n    } .?\n}\n\ndef docstr::_get__doc__ {self,\n    d._module nil = {\n        .# Access from scope\n        {__doc__;} {;{,}:__doc__;} .K\n\n        __doc__\n    } {\n        .# Access from module\n        {d._module.__doc__;} {; {,} d._module.:__doc__;} .K\n\n        d._module.__doc__\n    } .?\n}\n\ndef docstr::_padlines {n s,\n    s.lines :#{\" \"nLW\\+\"\\n\"} W\n}\n\ndef docstr::show {self : builtin docstr^,\n    [::desc ::args ::example]:builtin;\n\n    [\n        self._get_name\n        .E \"-\" \\LW\n        self.sections.desc\n        \"\"\n        \"args:\"\n        self._args #{2 \\ .show}~\n        \"\"\n        \"example:\"\n        2 self.sections.example docstr._padlines\n        self.sections :K .[{builtin \\ H}] :# {k,\n            k :C\n            2 self.sections.[k] docstr._padlines\n        } ~\n    ] #'\\n'+ W .trim\n}\n\n\ndef docstr::add_to_help {self,\n    [\".{?\" self.show \".}\"]W~\n}\n\ndef docstr::to_html {self,\n    [\n        \"<h2>$(self._get_name)</h2>\"\n        \"<br />\"\n        \"<p>$(self.sections.desc)</p>\"\n        \"<h4>Args:</h4>\"\n        \"<ul>\"\n        self._args\n    ] #'\\n'+ W .trim\n}\n\n\n{(2 hold)({:d,\n    docstr! :d:dd;\n\n    .# Add the doc to the module (or global scope)\n    .# Create __doc__ if it does not yet exist\n    d d._name d._get__doc__ :D ;\n    d.add_to_help\n})}:doc;\n\ndef docstr::__repr__ {self,\n    \"<docstr for $(self._name :C)>\"\n}\n\n\n{(1 hold)({x,\n    x :T ::list = {\n        x.[0].__doc__.[x.[1]] .show :P\n    } ?\n})}:help;\n\n.{\nstruct example {a b}\n\ndoc [example::variable] \"\"\"\n    Some description of the variable or function\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Aliquam pulvinar, metus et pretium malesuada, risus\n    risus pulvinar lacus, ut molestie neque sapien at felis.\n    (by default, this text ends up in the \"desc\" key\n\n@args:\n    ::num: the first stack arg\n    ::list: the second stack arg\n    a: what a is for\n        more info about a\n  more about a\n  b: what b is for\n\n@example:\n    aya> {x, a x +}.capture[::a]\n    {x : a , a x + }\n    aya> {x, a x +}.capture[::a] :f\n    {x : a , a x + }\n    aya> 5 f\n    6\n    aya> 2:a\n    2\n\n@other_key:\n    more text that will end up in the above key\n\"\"\"\ndef example::variable {a b::num, }\n.}\n", "std/set.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# set.aya\n.# Defines the set data structure\n\n.{? type: set\n    The set type is a simple list type where there exits no duplicate elements.\n    Create a set by entering a list followed by the set constructor\n.}\n\n\nclass set\nexport [::set ::s]\n\ndef set::__init__ {l::list self,\n    l self.:list ;\n}\n\n\n.#\n.# Adding / Removing elements\n.#\n\n.#? ::any ::set.__add__\\n  add an item to a set\ndef set::__add__ {item self,\n    item self.in ! {self.list [item] :J;} ? self\n}\n\n.#? ::any ::set.__sub__\\n  remove an item from a set\ndef set::__sub__ {item self,\n    self.list [item] :| self.:list\n}\n\n\n\n.#\n.# Set operations\n.#\n\n.#? ::set ::set.__or__\\n  set union\ndef set::__or__ {other::set self,\n    other.list $ \\; self.list :J :~ self.M!\n}\n\n.#? ::set ::set.__and__\\n  set intersection\ndef set::__and__ {other::set self : l,\n    self.list :l;\n    other.list # {l \\N$ 0:> {I} {;;} .?} self.M!\n}\n\n\n.#? ::set ::set.__div__\\n  set difference\ndef set::__div__ {other::set self,\n    other.list $\\; self.list :| self.M!\n}\n\n\n.#? ::set ::set.__eq__\\n test if two sets are the same\ndef set::__eq__ {other::set self,\n    other.list self.list =\n}\n\n\n.#? ::set ::set.__lt__\\n  proper subset\ndef set::__lt__ {other::set self,\n    other self.__leq__            .# subset\n    other.list self.list = !  .# proper subset\n    &\n}\n\n.#? ::set ::set.__gt__\\n  proper subset\ndef set::__gt__ {\\.__lt__}\n\n\n.#? ::set ::set.__leq__\\n subset\ndef set::__leq__ {other::set self : l,\n    other.list :l;\n    self.list # { l \\ N \\; 0 :>} {*} %\n}\n\n.#? ::set ::set.__geq__\\n subset\ndef set::__geq__ {\\.__leq__}\n\n\n\n.#\n.# Other functions\n.#\n\n.#? ::any ::set.in\\n  tests if an item is in a set\ndef set::in {item self,\n    self.list item N\\; 0 :>\n}\n\n\n.#? ::set.__len__\\n  returns the number of elements in the set\ndef set::__len__ { .list E }\n\n\n.#? ::set.clear\\n  clear the contents of a set\ndef set::clear {[]\\ .:list}\n\ndef set::__repr__ {.listP\"s\"\\+}\ndef set::__str__  {.listP\"s\"\\+}\n\ndef set::__each__ {blk self,\n    self.list :# {blk}\n}\n\n\n{{~set!} 0 :`}:s;\n", "std/rdatasets.aya": "import ::csv\n\n\nmodule rdatasets\nexport ::rdatasets\n\ndef rdatasets::_index_csv \"https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/datasets.csv\"\ndef rdatasets::_cache_loc \"rdatasets_index.csv\"\n\n.# Load index file\ndef rdatasets::load_index {:index_str(\"\") data index({,}) packages({,}),\n\n    {\n        rdatasets._cache_loc G :index_str;\n    } {\n        \"Downloading dataset from $(rdatasets._index_csv)...\" :P\n        rdatasets._index_csv G :index_str;\n        index_str rdatasets._cache_loc 0 .G\n    } .K\n\n    \"Parsing CSV...\" :P\n    index_str \",\" csv.parse :data;\n    data V; :data; .# Remove first row\n\n    data :d;\n\n    .# Build index\n    \"Building index...\" :P\n    data :# {row : pkg(row.[0]) name(row.[1]),\n        .# Add to url index\n        row.[-2] index.:[\"$pkg/$name\"]\n\n        .# Add to package index\n        .# Add package list if it does not exist\n        packages pkg H ! { [] packages.:[pkg]; } ?\n        .# Add name to list\n        name packages.[pkg] .B ;\n\n    };\n    \"Done.\" :P\n\n    def rdatasets::index index\n    def rdatasets::packages packages\n}\n\n\ndef rdatasets::index {,}\ndef rdatasets::packages {,}\n\ndef rdatasets::load {id::str : rdatasets^ csv^,\n    rdatasets.index :E 0 = {\n        rdatasets.load_index\n    } ?\n    \n    \"/\" id.in {\n        rdatasets.index.[id]\n    } {\n        rdatasets.index.[\"datasets/$id\"]\n    } .?\n\n    csv.open\n}\n\n\nrdatasets:r;\n\n\n\n\n", "std/map.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# map.aya\n.# Defines the map data structure\n\n.{? class: map\n    The map type is a key-value pair dictionary which supports any\n      and mixed data types as the key.\n.}\n\nclass map\nexport ::map\n\ndef map::__init__ {self,\n    [] self.:keys;\n    [] self.:values;\n}\n\n\n.#? key map.haskey\\n  true if map contains key\ndef map::haskey {key self,\n    self.keys key H\n}\n\n\n.#? key value self map.put\\n  put key value pair in the map\ndef map::put {value key self : idx,\n    self.keys key N :idx;;\n    idx 0 < {\n        key self.keys .B;\n        value self.values .B;\n    } {\n        value self.values.:[idx];\n    } .?\n}\n\n\n.#? key ::map.del\\n  remove the key value pair from thist list\ndef map::del {key self,\n    .# Apply remove code only if it is in the map\n    self.keys key N $ 0 :> {\n        $@\\.-;              .# remove from keys\n        self.values\\.-;     .# remove from values\n    } {\n        ;;                  .# do nothing, clean stacke\n    } .?\n}\n\n\n.#? key map.getindex\\n  get the value for the key in the map\ndef map::__getindex__ {key self : idx,\n    self.keys key N :idx;;\n    idx 0 < {\n        \"map does not contain key $key\" .D\n    } {\n        self.values.[idx]\n    }.?\n}\n\n.#? ::block ::map.__each__\\n  apply the block to each key value pair\n.{ Example:\naya> [[1 \"one\"][2 \"two\"]] map.fromlist :m\n{,\n  [ 1 2 ]:keys;\n  [ \"one\" \"two\" ]:values;\n}\naya> m :# {k v, v.upper k m.put}\naya> m\n{,\n  [ 1 2 ]:keys;\n  [ \"ONE\" \"TWO\" ]:values;\n}\naya> m :# {k v, \"$k = $v\" :P}\n1 = ONE\n2 = TWO\n.}\ndef map::__each__ {blk self,\n    [self.keys self.values] .T :# {~ blk} ;\n}\n\n\ndef map::fromlist {list map : m,\n    map!:m;\n    list # {~ \\m.put};\n    m\n}\n", "std/stats.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\nmodule stats\nexport ::stats\n\nfrom ::math import ::cumsum\n\n.#? ::list stats.mean\\n  average of a list of numbers\ndef stats::mean {\n    .E\\W\\/\n}\n\n\n.#? ::list stats.variance\\n  population variance\ndef stats::variance {set : m stats^,\n    set stats.mean:m;\n    set#{m- 2^} W setE /\n}\n\n\n.#? L stats.stdev\\n  standard deviation\ndef stats::stdev {: stats^,\n    stats.variance .^\n}\n\n\n.#? ::list stats.geomean\\n  geometric mean\n.# the nth root of the product of n numbers\n.# compute by summing the logarithms of the values\ndef stats::geomean {\n    Ml.E\\W\\/Me\n}\n\n\n.#? L stats.median\\n  median value of a list\ndef stats::median {l,\n    lC$E2/.\\        .# Sort the list and get its middle index\n    lE2:%0= {        .# If the list has even length,\n        $1-:JIW2/    .# average the middle two\n    } {\n        I           .# else, take the middle item\n    }  .?\n}\n\n\n.#? ::list ::list stats.regression\\n  return a block that evaluates to the regression of the sets\ndef stats::regression {x y :\n    n a b\n    sumy sumx\n    sumxsq\n    sumxytimes,\n\n    xE:n;\n    x2#^W:sumxsq;\n    [x y,*]W:sumxytimes;\n    xW:sumx;\n    yW:sumy;\n\n\n    sumy sumxsq *  sumx sumxytimes * -\n    n sumxsq * sumx2^ -\n    /:a;\n\n    n sumxytimes * sumx sumy * -\n    n sumxsq * sumx2^-\n    /:b;\n\n    {b * a +} [::a ::b] .+\n}\n\n\n.#? ::list ::list stats.pearson\\n  pearson correlation coefficient between 2 datasets\ndef stats::pearson {x y : n xs ys,\n    xE:n;\n    xW:xs;\n    yW:ys;\n\n    [x y,*]Wn* xs ys*-\n     x2^Wn* xs2^ -\n     y2^Wn* ys2^ -\n     * .^\n    /\n}\n\ndef stats::hist {l::list nbins::num : min max bin_size bins counter cumsum^,\n    .# compute bin size using list min and max values\n    l.min :min;\n    l.max :max;\n    max min - nbins / :bin_size;\n\n    .# generate list of bins\n    .# for example, if 2:bin_size, 1:min, 5:nbins\n    .#    [ 3 5 7 9 11 ] :bins\n    bin_size nbins L cumsum min + :bins;\n\n    .# Set last bin to max value (prevent rounding errors)\n    max bins.:[-1];\n\n    .# Create a list of counters\n    [nbins,; 0] :counter;\n\n    .# Map each item to it's bin index\n    l #{bins>W}\n    .# count all bin indices\n    :# {i, counter.[i] 1 + counter.:[i]};\n\n    counter\n}\n", "std/docs.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# docs.aya\n.# Basic documentation for Aya that appears in the quicksearch\n\n.{? docs: comments\n   .# this is a line comment\n   .{\n     this is a block comment\n   .\\}\n\n   .#? this line will be added to interactive help\n   .{?\n      these lines will be\n      added to interactive help\n   .\\}\n.}\n\n.{? docs: argument type key\n  ::num - num\n  ::block - block\n  ::char - character\n  ::str - string\n  ::any - any\n  ::dict - dict\n  ::sym - symbol\n.}\n\n.{? docs: ranges\n  ranges are used in list comprehension notation for creating quick lists\n  they can be built from all number types, characters, strings, and list literals\n  examples:\n   [2,] => [1 2]\n   [2 5,] => [2 3 4 5]\n   [0 2 6,] => [0 2 4 6]\n   ['a 'c,] => [a b c]\n   [\\\"hi\\\",] => [h i]\n   [[1 2],] => [1 2]\n.}\n\n.{? docs: list comprehension\n  a range is always required. map and filter blocks are not.\n\n  syntax:\n  [\n    <range>,\n    <map>,\n    <filter1>,<filter2>,..<filterN>\n  ]\n.}\n\n.{? docs: blocks\n  blocks are containers for a group of operations and a list of arguments.\n  syntax:\n    {<expr>}\n    {<args> , <expr>}\n    {<args> : <locals> , <expr>}\n    {: <locals> , <expr>}\n.}\n\n.{? docs: dictionaries\n  dicts are created using the following syntax\n  {, val1:key1 val2:key2 ... valN:keyN}\n.}\n\n.{? docs: special characters\n  unicode: '\\U263A' => \\{U263A}\n  named:   '\\in' => \\{in}\n  strings: \"I \\\\{heart} element\" => \"I \\{heart} element\"\n.}\n\n.{? docs: negative numbers\n  use :<number> or :-<number> for number literals only\n  use the (T) operator to negate a variable\n.}\n\n.{? docs: list grabbing\n  List literals can grab items from the outer stack\n  Use the format `... [num| ...]` where `num` is an num literal\n  ex: 1 2 [1| 7 6] => 1 [2 7 6]\n  ex: 4 [1|10,] => [4 5 6 7 8 9 10]\n.}\n\n.{? docs: constants\n  use `:Nc` where N is:\n  0: pi\n  1: e\n  2: double max\n  3: double min\n  4: NaN\n  5: +inf\n  6: -inf\n  7: int max\n  8: int min\n  9: system file separator\n  10: system path separator\n  11: char max value\n  12: system line separator\n.}\n", "std/random.aya": ".# This file is a part of aya: https://github.com/aya-lang/aya\n\n.# Functions related to random number generation\n\nmodule random\nexport ::random\n\n.#? ::list ::num random.lotto\\n  pick N random items from L\ndef random::lotto {\n    \\.EV@L#QI\n}\n\n.#? lo::num hi::num random.randint\\n  random integer between lo and hi\ndef random::randint {\n    \\$@\\-Q+\n}\n", "std/dataframe.aya": "import ::csv\n\nclass dataframe\nexport ::dataframe\n\ndef dataframe::__init__ {kwargs::dict self :\n        data(nil)\n        colnames(nil)\n        index(nil),\n\n    kwargs ~\n\n    [] self.:_colnames;\n    [] self.:_index;\n    [] self.:_data;\n\n    .# Create using data\n    data nil =! {:numrows numcols,\n        data E :numrows;\n        data .TE :numcols;\n        data self.:_data;\n\n        .# Column names\n        colnames nil = {\n            numcols self.M._gen_colnames\n        } {\n            colnames\n        } .? self.:_colnames;\n\n        .# Row names\n        index nil = {\n            numrows .R\n        } {\n            index\n        } .? self.:_index;\n    } ?\n\n    self._check_size\n}\n\ndef dataframe::_check_size {self,\n    self._dataE self._indexE = ! {\n        \"dataframe!: data size ($(self._dataE)) and index length ($(self._indexE)) do not match\" .D\n    } ?\n\n    self._data.TE self._colnamesE = ! {\n        \"dataframe!: data num cols ($(self._data.TE)) and length of colnames ($(self._indexE)) do not match\" .D\n    } ?\n}\n\ndef dataframe::_gen_colnames {n::num cls,\n    n 26 :< {\n        ['a $nV+] R#P\n    } {\n        n 26- :n;\n        \"az\"R#P\n        n 26 .% 'a$@+ :J R \"az\"R {\\P+}.pu #~ n .< :J\n    } .?\n}\n\n.# CSV Utils\n.###########\n\ndef dataframe::from_csv {csv_dict cls,\n    {,\n        csv_dict.data :data;\n        csv_dict.rownames :index;\n        csv_dict.colnames :colnames;\n    } dataframe!\n}\n\ndef dataframe::read_csv {arg cls: dataframe^ csv^ ,\n    .# csv.read takes a string or a kwargs dict\n    arg csv.read dataframe.from_csv\n}\n\ndef dataframe::to_csv { kwargs self : csv^ noindex(0) colnames(1) sep(\",\"), kwargs ~\n    self._data \n    colnames { self._colnames A \\ J } ?\n    noindex! { \n        self._index\n        colnames {[\"\"] \\ J} ?\n        \\ {J} .&\n    } ?\n    sep nil\n    csv.dumps\n}\n\n.# Indexing\n.##########\n\ndef dataframe::_get_col_index {colname self,\n    colname :T ::sym = {colname :C :colname; } ?\n    self._colnames colname N\\; :colindex;\n    colindex 0 < {\n        \"Column $colname not found\" .D\n    } ?\n    colindex\n}\n\ndef dataframe::_get_col {colname self : colindex,\n    colname self._get_col_index :colindex;\n    self._data :# { colindex I }\n}\n\ndef dataframe::_numgetindex {index::num self : dataframe^,\n    {,\n        [self._data.[index]]  :data;\n        [self._index.[index]] :index;\n        self._colnames :colnames;\n    } dataframe!\n}\n\ndef dataframe::__getindex__ { index self : dataframe^,\n    {\n        (index :T ::num =) {\n            index self._numgetindex\n        } (index :T ::str =) {\n            index self._get_col\n        } {\n            \"Unsupported index: $index\" .D\n        }\n    } :?\n}\n\n.{\n    aya> df\n        A B C\n    0 | 1 2 3\n    1 | 4 5 6\n    2 | 7 8 9\n    aya> df.row[1]\n        A B C\n    0 | 4 5 6\n    aya> df.row[[1 2]]\n        A B C\n    0 | 4 5 6\n    1 | 7 8 9\n.}\ndef dataframe::row {(1 hold)({self index : data,\n    self._data.[index~]:data;\n    [ index~ :T ::num = { [data]:data } ? ];\n\n    {, self._colnames:colnames data:data } dataframe!\n})}\n\n\n.{\n    aya> df\n        A B C\n    0 | 1 2 3\n    1 | 4 5 6\n    2 | 7 8 9\n    aya> \"C\" {5>} df.filter_on_col\n        A B C\n    0 | 4 5 6\n    1 | 7 8 9\n.}\ndef dataframe::filter_on_col {column condition self : colindex,\n    column self._get_col_index :colindex;\n    self.row[ { .[colindex] condition } ]\n}\n\n\ndef dataframe::nrows {self,\n    self._data E\n}\n\ndef dataframe::ncols {self,\n    self._data.[0] E\n}\n\ndef dataframe::shape {self,\n    [self.nrows self.ncols]\n}\n\ndef dataframe::colnames {self,\n    self._colnames\n}\n\ndef dataframe::rows {self,\n    self._data\n}\n\n\n.# Serialization / Output\n.########################\n\ndef dataframe::__str__ {self : max_idx_len,\n    .# find longest index name\n    self._index #{PE} .max :max_idx_len;\n    .# pad indices to lo\n    self._index :#{P max_idx_len .> \" |\" +}\n    .# Zip the index and the data along each row\n    self._data {J}.&\n    .# Add a \"\" to the front for the index column\n    \"\" self._colnames#P J\n    .# Add the colum as the first elemnt in the list\n    A\\J\n    .# Convert to a pretty matstr\n    .matstr\n}\n\ndef dataframe::to_html {kwargs::dict self : noindex(0) data style(\"\") border(0),\n    kwargs ~\n    self._data :data;\n    noindex ! {\n        self._index self._data {J} .& :data;\n    } ?\n\n    [] :out;\n    \"<table style=\\\"$style\\\" border=\\\"$border\\\">\" out.B;\n    data :# {row,\n        \"<tr>\" out.B;\n        row :# {x, \"<td>$x</td>\" out.B } ;\n        \"</tr>\" out.B;\n    } ;\n    \"</table>\" out.B;\n\n    out W\n}\n\ndef dataframe::_repr_lines {s::str cls : lines,\n    s.lines :lines;\n    lines E 24 > {\n        [lines 10 .<~ \"...\" lines 10 .>~]\"\\n\" %\n    } {\n        s\n    } .?\n}\n\n\ndef dataframe::__repr__ {self : dataframe^,\n    self.__str__ dataframe._repr_lines\n}\n", "std/matrix.aya": "import ::mp\n\nclass matrix\nexport ::matrix\n\n.# Test if list is a valid matrix\ndef matrix::_is_valid_list {m::list matrix,\n    .# Both of the following must be true:\n    m :#{:T::list=} .allt   .# The list is made up of only other lists\n    {\n        m :#{Em0IE=} .allt  .# All of the list lengths are the same\n    } 0 .?\n}\n\ndef matrix::__init__ {input::list self,\n    input self.M._is_valid_list {\n        input self.:rows;\n    } {\n        \"$input is not a valid matrix\" .D\n    } .?\n}\n\n.# Use this instead of the constructor to avoid\n.# validating the list\ndef matrix::_new {matrix,\n    {1, :rows} matrix :M\n}\n\n.{ Example:\n    aya> [3 3] matrixR 10^\n    [[ 1         1024       59049      ]\n     [ 1048576   9765625    60466176   ]\n     [ 282475249 1073741824 3486784401 ]]\n.}\ndef matrix::__repr__ {self,\n    self.r self.c + 100 > {\n        \"($(self.r)x$(self.c) matrix)\"\n    } {\n       self.rows .matstr \"\\n\" \" ]\\n [ \" .& \"[[ \" \\+ \" ]]\"+\n    } .?\n}\n\n\n.# Vectorized Operator Overloads\n.###############################\n\n.# Binary\n.# ------\n\n[\n    ::__sub__ ::__div__\n    ::__pow__ ::__lt__  ::__gt__  ::__mod__\n    ::__leq__ ::__geq__ ::__idiv__\n] :# {op_sym : mp^ op_to_n op rop rop_sym,\n    \n    [::n op_sym] mp.merge :op_to_n;\n    op_sym.op :op;\n    [::other {\\} op_sym] mp.merge :rop;\n    op_sym.rev :rop_sym;\n\n    def matrix op_sym {other self : op^ rop^,\n        {\n            (other :T ::matrix =) {\n                other.rows self.rows op.` .& self.M._new\n            } (other :T ::num =) {\n                self.rows :# rop.` self.M._new\n            } { \n                \"TypeError: Invalid operation $(other:T) $(self:T) *\" .D\n            }\n        } :?\n    }\n\n    def matrix rop_sym {self n::num : op_to_n^, self.rows :# {op_to_n} self.M._new}\n}\n\ndef matrix ::__mul__ { other self,\n    {\n        (other :T ::matrix =) {\n            selfE otherE = {\n                other.rows self.rows {*} .& self.M._new\n            } {\n                self.rows other.rows  {{*}:*{~}O}:*{~}O self.M._new\n            } .?\n        } (other :T ::num =) {\n            self.rows {other *} O self.M._new\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\ndef matrix::__rmul__ {self n::num,\n    self.rows [n {*}].* O self.M._new\n}\n\ndef matrix::matmul {other self, \n    other.rows self.rows :{la.mul} self.M._new\n}\n\ndef matrix ::__add__ { other self,\n    {\n        (other :T ::matrix =) {\n            selfE otherE = {\n                other.rows self.rows {+} .& self.M._new\n            } {\n                self.rows other.rows  {{+}:*{~}O}:*{~}O self.M._new\n            } .?\n        } (other :T ::num =) {\n            self.rows {other \\+} O self.M._new\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\ndef matrix::__radd__ {self n::num,\n    self.rows {n +} O self.M._new\n}\n\n\n\n\n.# Unary\n.# -----\n[\n    ::__floor__ ::__ceil__ ::__negate__ ::__abs__ ::__signnum__\n    ::__sqrt__ ::__exp__ ::__ln__ ::__log__\n    ::__sin__ ::__asin__ ::__cos__ ::__acos__ ::__tan__ ::__atan__\n] :# {sym : op,\n    sym.op :op;\n    def matrix sym ({\n        :& .rows op #~ \\.M._new\n        } {, op.`:op } .+\n    )\n}\n\n.# Other Overloads\n.# ---------------\n\n\ndef matrix::_eq_num {n self,\n    self.rows n .= self.M._new\n}\n\ndef matrix::_eq_list {l self,\n    self.rows :# {\n        .# Test if the current item is in the list\n        :# {l \\ H}\n    } self.M._new\n}\n\ndef matrix::_eq_mat {a b,\n    aE bE =! 0 {a.rows b.rows =} .?\n}\n\n.#? ::matrix ::matrix =\\n  test if two matrices are equal\n.#? ::list ::matrix =\\n  return a matrix of booleans where true if the corresponding element is in the input list\n.#? ::num ::matrix =\\n  return a matrix of booleans there true if the corresponding element is equal to the input number\ndef matrix::__eq__ ({a b,\n    a b\n    .# swap args if b is not a matrix\n    b :T ::matrix =! {\\} ?\n    __fn 3.$ :T I ~\n} {,\n    {,\n        matrix._eq_list.` :list;\n        matrix._eq_num.`  :num;\n        matrix._eq_mat.`  :matrix;\n    }:__fn\n} .+)\n\n\n.#? ::matrix ::matrix &\\n  element-wise and\ndef matrix::__and__ {:matrix^, .rows\\.rows {{&}.&}.& matrix._new}\n\n.#? ::matrix ::matrix |\\n  element-wise or\ndef matrix::__or__  {:matrix^, .rows\\.rows {{|}.&}.& matrix._new}\n\n\n\n\n.#####################\n.# Matrix Operations #\n.#####################\n\n.#? ::matrix ::matrix.sq\\n  square each value in the matrix\ndef matrix::sq { :& * }\n\n\n.#? ::matrix matrix.issq\\n  returns true if the list is a square matrix\ndef matrix::issq {self, self.rowsE self.rows#E\\#= `| %}\n\n.#? ::matrix matrix.tr\\n  trace of a matrix as a list\ndef matrix::tr {[1|.rows$ER,VI]}\n\n.#? ::matrix matrix.t\\n  transpose a matrix\ndef matrix::t {:&.rows.T\\.M._new}\n\n.#? ::matrix.max\\n  the max value of a matrix\ndef matrix::max {.rows#.max.max}\n\n.#? ::matrix.min\\n  the min value of a matrix\ndef matrix::min {.rows#.min.min}\n\n.#? ::matrix.norm\\n  normalize the matrix\ndef matrix::norm {:& .sq .sum .^ /}\n\n.#? ::matrix.sum\\n  the sum of all values in the matrix\ndef matrix::sum {.rows #WW}\n\n.#? ::matrix.mean\\n  the mean of all values in the matrix\ndef matrix::mean {.E~* \\.sum\\/}\n\ndef matrix::dot {o self : t matrix^,\n    o.c self.r =! {\n        \"matrix.mul: shape mismatch $(o.c) != $(self.r)\".D\n    } ?\n    .# (*W) is the dot product\n    self.rows.T :t;\n    o.rows  :# {r, t :#{r *W}}\n    matrix._new\n}\n\n.#? ::matrix.r\\n  number of rows\ndef matrix::r {.rowsE}\n\n.#? ::matrix.c\\n  number of cols\ndef matrix::c {.rows.[0] E}\n\n.###################\n.# Transformations #\n.###################\n\n.#? ::matrix ::matrix.hcat\\n  concatenate horizontally\ndef matrix::hcat {a::matrix b::matrix,\n    a.rows b.rows {J} .& a.M._new\n}\n\n.#? ::matrix ::matrix.vcat\\n  concatenate vertically\ndef matrix::vcat {a::matrix b::matrix,\n    a.rows b.rows J a.M._new\n}\n\n.#? ::num ::matrix.rotate_cols\\n  shift columns of a matrix right N times\n.#? ::num ::matrix.rotate_rows\\n  shift rows of a matrix down N times\n.{ Example:\n    aya> [3 3]matrixR\n    [[ 1 2 3 ]\n     [ 4 5 6 ]\n     [ 7 8 9 ]]\n\n    aya> 1 [3 3]matrixR.rotate_rows\n    [[ 7 8 9 ]\n     [ 1 2 3 ]\n     [ 4 5 6 ]]\n\n    aya> 1 [3 3]matrixR.rotate_cols\n    [[ 3 1 2 ]\n     [ 6 4 5 ]\n     [ 9 7 8 ]]\n.}\ndef matrix::rotate_cols {:matrix^,\n    .rows \\ #{\\.rotate} matrix._new\n}\n\ndef matrix::rotate_rows {:matrix^,\n    .rows .rotate matrix._new\n}\n\ndef matrix::circshift {rc self : m,\n    rc.[0] self.rotate_rows :m;\n    rc.[1] m.rotate_cols\n}\n\n.#? [rows cols] ::matrix .<\\n  cut or pad the matrix to the given size from the upper left corner\n.{? Example:\n\n    aya> [2 2] matrixR [3 3] .<\n    [[ 1 2 0 ]\n     [ 3 4 0 ]\n     [ 0 0 0 ]]\n\n    aya> [2 2] matrixR [3 2] .<\n    [[ 1 2 ]\n     [ 3 4 ]\n     [ 0 0 ]]\n\n    aya> [2 2] matrixR [3 1] .<\n    [[ 1 ]\n     [ 3 ]\n     [ 0 ]]\n\n    aya> [2 2] matrixR [2 3] .<\n    [[ 1 2 0 ]\n     [ 3 4 0 ]]\n\n    aya> [2 2] matrixR [1 3] .<\n    [[ 1 2 0 ]]\n.}\ndef matrix::__head__ {self n::list : d,\n    n E 2 =! {\"dimension of take must be 2\" .D} ?\n\n    .# rows\n    self.rows n.[1] #.<\n\n    .# cols\n    .# Pad the list with 0s\n    n.[0] .<\n    .# create empty list equal to the length of the first element\n    .# ex: cols=5 then create [0 0 0 0 0]\n    0 dot_i E 0\\L :d;\n    .# Replace 0s with the empty list\n    :# {$ 0 = {;d} ?}\n\n    self.M._new\n}\n\n\n.#? [rows cols] ::matrix .<\\n  cut or pad the matrix to the given size from the bottom right corner\ndef matrix::__tail__ {self n::list : d,\n    n E 2 =! {\"dimension of take must be 2\" .D} ?\n\n    .# rows\n    self.rows n.[1] #.>\n\n    .# cols\n    .# Pad the list with 0s\n    n.[0] .>\n    .# create empty list equal to the length of the last element\n    .# ex: cols=5 then create [0 0 0 0 0]\n    -1 dot_i E 0 \\L :d;\n    .# Replace 0s with the empty list\n    :# {$ 0 = {;d} ?}\n\n    self.M._new\n}\n\n\n.#? ::num ::matrix.pad\\n  insert N outer cols and rows of zeros\n.{ Example:\n    aya> 1 4R [2 2]L matrix!.pad\n    [[ 0 0 0 0 ]\n     [ 0 1 2 0 ]\n     [ 0 3 4 0 ]\n     [ 0 0 0 0 ]]\n.}\ndef matrix::pad {n::num self : r c,\n    self.r :r;\n    self.c :c;\n\n    self [r n + c n +] .<\n    [r n2* + c n2* +] .>\n}\n\n\n\n\n.#############\n.# Overloads #\n.#############\n\n.#? ::matrix U\\n  reverse the rows of a matrix\ndef matrix::__reverse__ {:& .rows U \\.M._new}\n\n.#? ::matrix E\\n  the shape of the matrix\ndef matrix::__len__ {.rows.E\\0IEJ}\n\n\n.#############\n.# Iteration #\n.#############\n\n\n.#? ::block ::matrix matrix.apply\\n  apply an expression to each element of the matrix in place\ndef matrix::apply {expr::block self,\n    self.rows # {#expr} self.:rows; self\n}\n\n.#? ::block ::matrix matrix.map\\n  apply an expression to each element of a matrix, return nothing\ndef matrix::map {expr::block self,\n    self.rows #{#expr};\n}:map;\n\n.#? ::matrix :# ::block \\n  make a copy of the matrix and apply an expression to each element\ndef matrix::__each__ {expr::block self,\n    self.rows$ :#{:#{expr}} self.M! \\;\n}\n\n\n\n.############\n.# Indexing #\n.############\n\n\n.# value row column matrix::_set\n.# Set the value of a location in a matrix\ndef matrix::_set {value r::num c::num self,\n    value self.rows.[r].:[c]; self\n}\n\n.#? matrix::cols\\n  return a copy of the matrix columns\ndef matrix::cols {.rows .T}\n\n.#? ::matrix [rows cols] I\\n get an item or a submatrix\ndef matrix::__getindex__ {ix mat : r c matrix^,\n    ix0I :r;\n    ix1I :c;\n\n    .# Get the data\n    mat.rows r I\n    r :T ::num = {A} ?\n    #{cI}\n\n    .# Transform the data based on input type\n    .# Return a new matrix if possible\n    c :T ::num = {\n        r :T ::num = {\n            .# `r` and `c` both nums, return a single item\n            0I\n        } {\n            .# Only columns returned, wrap each in a list\n            #A matrix!\n        } .?\n    } {\n        .# Only rows returned, convert to matrix\n        matrix!\n    } .?\n}\n\ndef matrix::__setindex__ {val ix self : r c matrix^,\n    {\n        (ix :T ::matrix =) {\n            val :T ::matrix = {val.rows :val;} ?\n            val :T ::list = {\n                val self.rows ix.rows [3|,D];\n            } {\n                self.rows ix.rows {val @@ D} .&;\n            } .?\n            self\n        } (ix :T ::list =) {\n            val ix.[0] ix.[1] self._set\n        } {\n            \"TypeError: Invalid operation $(other:T) $(self.T) *\" .D\n        }\n    } :?\n}\n\n.##############\n.# Generators #\n.##############\n\n.#? N matrix.eye\\n  generate an Nd identity matrix\ndef matrix::eye {matrix,\n    $0\\L1\\:J\\$:JL  matrix._new\n}\n\n.# generates the next row of a pascal matrix\ndef matrix::_nextpascal {prev::list matrix : new len ix,\n    prevE:len;\n    1 0 lenVL:J:new;\n    1:ix;\n    {prev ixI new ixVI+ new.:[ix]; ::ix B}lenV%\n    new\n}\n\n.#? I matrix.pascal\\n  generate an I by I matrix representation of pascal's triangle\n.{ Example:\n    aya> 4 matrix.pascal\n    [[ 1 1 1  1  ]\n     [ 1 2 3  4  ]\n     [ 1 3 6  10 ]\n     [ 1 4 10 20 ]]\n.}\ndef matrix::pascal {n::num matrix,\n    [1 n L {$matrix._nextpascal} n V %] matrix._new\n}\n\n.#? [rows cols] matrix::R\\n  generate a matrix counting up from 1\ndef matrix::__range__ {l::list matrix,\n    l~*R l L matrix!\n}\n\n.#? [rows cols] matrix.random\\n  create a N1 by N2 matrix of random values [0,1]\ndef matrix::__random__ {matrix,\n    0\\L :#{:#{;.Q}} matrix._new\n}\n\n.# rows::num cols::num matrix._newfill\\n  create a I1 by I2 matrix filled with N3\ndef matrix::_newfill {matrix, \\L\\Lmatrix._new}\n\n.#? [rows cols] matrix.ones\\n  create a N1 by N2 matrix of ones\ndef matrix::ones  {matrix, ~ 1 matrix._newfill}\n\n.#? [rows cols] matrix.zeros\\n  create a N1 by N2 matrix of zeros\ndef matrix::zeros {matrix, ~ 0 matrix._newfill}\n\n.#? value::num [rows cols] matrix.full\\n  create a rows x cols matrix filled with value\ndef matrix::full {value::num shape::list matrix,\n    shape.[0] shape.[1] value matrix._newfill\n}\n\n\n\n.#? ::matrix.comma_str\\n  print the matrix in list with comma format\ndef matrix::comma_str {.rows :#{ \",\" % \"[\" \\+\"]\"+} \",\" % \"[\"\\+ \"]\"+}\n", "std/time.aya": "module time\nexport ::time\n\nclass rate\nrate time.:rate;\n\ndef rate::__init__ {hz self,\n    hz self.:hz;\n    1 hz / 1000 * self.:sleep_duration_ms;\n    M$ self.:last_sleep_time;\n}\n\ndef rate::sleep {self : time_since_last_sleep,\n    M$ self.last_sleep_time - :time_since_last_sleep;\n\n    self.sleep_duration_ms time_since_last_sleep -\n    .# floor and clip to 0\n    .\\ 0 .<\n    .# sleep\n    :Z\n\n    M$ self.:last_sleep_time;\n}\n", "std/image.aya": "from ::io import ::path\n\nmodule image\nexport ::image\n\nclass image\n\n.# Note pixels are signed bytes\n.# user .data :0xff & to get 0-255 values\n\ndef image::__init__ {data width height self,\n    data self.:data;\n    width self.:width;\n    height self.:height;\n}\n\ndef image::read {filename cls : img image^ path^,\n    filename path! P :{image.read} :img;\n    img.data img.width img.height image!\n}\n\ndef image::__repr__ {self,\n    \"(image $(self.width)x$(self.height))\"\n}\n\ndef image::write {filename self : path^,\n    {,\n        filename path! P:filename;\n        self.width :width;\n        self.height :height;\n        self.data :data;\n    } :{image.write}\n}\n\ndef image::pixels {self,\n    self.data [self.width self.height * 3] L\n}\n\ndef image::channels {self,\n    self.data [self.width self.height * 3] L .T\n}\n", "std/json.aya": "import ::io\n\nmodule json\nexport ::json\n\ndef json::loads {:{json.loads}}\n\ndef json::dumps {:{json.dumps}}\n\ndef json::load {json_file : file^ json^,\n    json_file :T ::str = {\n        json_file 'r file! :json_file;\n    } ?\n\n    json_file.do {f,\n        f.readall json.loads\n    }\n}\n\ndef json::dump {data json_file : file^ json^,\n    json_file :T ::str = {\n        json_file 'w file! :json_file;\n    } ?\n\n    json_file.do {f,\n        data json.dumps f.print;\n    }\n}\n", "std/queue.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# queue.aya\n.# Defines the queue data structure\n\n.{? type: queue\n    A simple queue data structure\n\n    Create queues by entering a list followed by the queue constructor\n    [1 2 3] queue!\n.}\n\n\nclass queue\nexport ::queue\n\n\n.#? ::list ::queue.__init__\\n  convert a list into a queue\ndef queue::__init__ {l self,\n    l self.:list ;\n}\n\n\n.# str and repr overloads\ndef queue::__str__ {self,\n    self.isempty {\n        \"queue: <- -<\"\n    } {\n        \"queue: <-\" self.list P B; V; \"-<\" ++\n    } .?\n}\n\n(queue.__str__.`,0); queue.:__repr__;\n\n\n.#? ::queue.next\\n  return the next item in the queue\ndef queue::next {self,\n    self.list E 0 = {\"queue obj is empty\".D} ?\n    self.list V \\ ;\n}\n\n\n.#? ::queue.peek\\n  return the next item in the queue without removing it from the queue\ndef queue::peek {self,\n    self.list E 0 = {\"queue obj is empty\".D} ?\n    self.list 0 I\n}\n\n.#? ::queue.__len__\\n  return the number of elements in the queue\ndef queue::__len__ { .list E }\n\n\n.#? ::queue.isempty\\n  tests if the queue is empty\ndef queue::isempty { .list E 0 = }\n\n\n.#? ::any ::queue.add\\n  add an item to the queue\ndef queue::__add__ {self,\n    self.list.B ; self\n}\n\n\n.#? ::queue.clear\\n  clear the queue\ndef queue::clear {self,\n    [] self.:list\n}\n\ndef queue::__each__ {blk self,\n    self.list :# {blk}\n}\n\n", "std/canvas.aya": "import ::color\nimport ::image\n\nexport ::canvas\n\nclass canvas\n\ndef canvas::__init__ {params::dict self : color^,\n\n    .# Default values\n    {,\n        400 :width\n        400 :height\n        \"Canvas\" :name\n        0 :autoflush\n        0 :show\n        color.colors.white :bg\n        color.colors.black :fg\n        params W\n    }:params;\n\n    params.width self.:width;\n    params.height self.:height;\n\n    .# Input\n    [-1 -1] self.:_last_mouse_pos;\n\n    .# ::new params 0 :{graphics.MG} self.:id ;\n    params :{graphics.new} self.:id ;\n}\n\ndef canvas::__str__ {self,\n    \"<canvas($(self.id))>\"\n}\n\n(canvas.__str__.`,0); canvas.:__repr__;\n\ndef canvas::delay {self,\n    self._delay_ms 0 > {self._delay_ms$:P :Z} ?\n}\n\ndef canvas::line {xa ya xb yb self,\n    .# ::line {, xa:xa ya:ya xb:xb yb:yb } self.id :{graphics.MG} ;\n    xa ya xb yb self.id :{graphics.line}\n}\n\ndef canvas::path {xs::list ys::list fill::num self,\n    xs ys fill self.id :{graphics.path}\n}\n\ndef canvas::point {x y self,\n    .#::line {, x:xa:xb y:ya:yb} self.id :{graphics.MG} ;\n    x y x y self.id :{graphics.line}\n}\n\ndef canvas::circle {x y r self,\n    x y r2* $ 0 self.id :{graphics.ellipse}\n}\n\ndef canvas::fillcircle {x y r self,\n    x y r2* $ 1 self.id :{graphics.ellipse}\n}\n\ndef canvas::set_color {color self,\n    .# ::set_color {, color.r:r color.g:g color.b:b } self.id :{graphics.MG} ;\n    color.r color.g color.b self.id :{graphics.set_color}\n}\n\ndef canvas::set_alpha {a self,\n    .# ::set_alpha {, a:a } self.id :{graphics.MG} ;\n    a self.id :{graphics.set_alpha}\n}\n\ndef canvas::set_stroke_width {n::num self,\n    n self.id :{graphics.set_stroke_width}\n}\n\ndef canvas::cap {,}\n\"butt\"   canvas.cap.:butt;\n\"round\"  canvas.cap.:round;\n\"square\" canvas.cap.:square;\n\ndef canvas::join {,}\n\"bevel\" canvas.join.:bevel;\n\"miter\" canvas.join.:miter;\n\"round\" canvas.join.:round;\n\ndef canvas::set_stroke {width::num cap::str join::str self,\n    width cap join self.id :{graphics.set_stroke}\n}\n\ndef canvas::set_grad {start::list ca::color end::list cb::color cycle::num self,\n    start.[0] start.[1] end.[0] end.[1]\n    ca.r ca.g ca.b ca.a 255*\n    cb.r cb.g cb.b cb.a 255*\n    cycle self.id :{graphics.set_paint_grad}\n}\n\ndef canvas::set_bg {color self,\n    .# ::set_bg {, color.r:r color.g:g color.b:b } self.id :{graphics.MG} ;\n    color.r color.g color.b self.id :{graphics.set_bgcolor}\n}\n\ndef canvas::save {filename self,\n    .# Convert to string (in case it is a path object)\n    filename P\n    .# Add file extension if it does not exist\n    \".png\" filename.in ! {\".png\"+} ?\n\n    self.id :{graphics.save}\n}\n\ndef canvas::close {self,\n    .# ::close {,} self.id :{graphics.MG} ;\n    self.id :{graphics.close}\n}\n\ndef canvas::show {self,\n    self.id :{graphics.show}\n}\n\ndef canvas::isopen {self,\n    self.id :{graphics.isopen}\n}\n\ndef canvas::rect {x y w h self,\n    .# ::rect {, x:x y:y w:w h:h } self.id :{graphics.MG} ;\n    x y w h 0 self.id :{graphics.rect}\n}\n\ndef canvas::fillrect {x y w h self,\n    .# ::rect {, x:x y:y w:w h:h 1:fill} self.id :{graphics.MG} ;\n    x y w h 1 self.id :{graphics.rect}\n}\n\ndef canvas::clear {self,\n    self.id :{graphics.clear}\n}\n\ndef canvas::viewmat {data self,\n    data self.id :{graphics.viewmat}\n}\n\n.# Block until the canvas is closed\ndef canvas::wait {self,\n    { 100:Z self.isopen } W\n}\n\ndef canvas::move_events {self,\n    self.id :{graphics.move_events}\n}\n\n.# Get the most recent mouse x/y\n.# return [-1 -1] if no updates\ndef canvas::mouse_pos {self : move,\n    self.move_events :move;\n    move E 0 > {\n        [move.[-1] :&.x\\.y] self.:_last_mouse_pos;\n    } ?\n    self._last_mouse_pos\n}\n\ndef canvas::pressed_buttons {self,\n    self.id :{graphics.pressed_buttons}\n}\n\ndef canvas::typed_chars {self,\n    self.id :{graphics.typed_chars}\n}\n\ndef canvas::pressed_keys {self,\n    self.id :{graphics.pressed_keys}\n}\n\ndef canvas::text {self,\n    self.id :{graphics.text}\n}\n\ndef canvas::get_pixels {self : data image^,\n    self.id :{graphics.get_pixels} :data;\n    data.data data.width data.height image!\n}\n", "std/stack.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# stack.aya\n.# defines the stack type\n\n.{? type: stack\n    A simple stack data structure\n\n    Create stacks by entering a list followed by the stack constructor\n    [1 2 3] stack!\n.}\n\n\nclass stack\nexport ::stack\n\n\n.#? ::list stack!\\n  convert a list into a stack\ndef stack::__init__ {l self,\n    l self.:list;\n}\n\n\ndef stack::__str__ {self,\n    self.isempty {\n        \"stack: <- -|\"\n    } {\n        \"stack: <-\"self.listPB;V;\"-|\"++\n    } .?\n}\n\n\ndef stack::__repr__ (stack.__str__.`)\n\n\n.#? ::stack.pop\\n  return the next item in the stack\ndef stack::pop {self,\n    self.listE0= {\"stack obj is empty\" .D} ?\n    self.listV\\;\n}\n\n.#? ::stack.peek\\n  return the next item in the stack without removing it from the stack\ndef stack::peek {self,\n    self.listE0= {\"stack obj is empty\" .D} ?\n    self.list0I\n}\n\n\n.#? ::stack.len\\n  return the number of elements in the stack\ndef stack::__len__ {.listE}\n\n\n.#? ::stack.isempty\\n  tests if the stack is empty\ndef stack::isempty {.listE0=}\n\n\n.#? A ::stack.add\\n  add an item to the stack\ndef stack::push {self,\n    self.list.V; self\n}\n\ndef stack::__add__ (stack.push.`)\ndef stack::__sub__ (stack.pop.`)\n\n.#? ::stack.clear\\n  clear the queue\ndef stack::clear {self,\n    [] self.:list\n}\n\n\ndef stack::__each__ {blk self,\n    self.list :# blk.`\n}\n", "std/dialog.aya": ".# This file is a part of Aya: https://github.com/nick-paul/aya-lang\n\n.# dialog.aya\n.# Interface to the dialog operator :{dialog.legacy}\n\n.{? dialog\n    various dialogs and windows\n    all functions in this module are shortcuts for the :{dialog.legacy} operator\n.}\n\nmodule dialog\nexport ::dialog\n\n\n.#? ::str dialog.requeststr\\n  request a string from the user\ndef dialog::getstr {question,\n    question :{dialog.getstr}\n}\n\n.#? ::str dialog.requestnum\\n  request a number from the user\ndef dialog::getnum {question,\n    question :{dialog.getnum}\n}\n\n.#? ::str dialog.alert\\n  display a dialog box with a given message\ndef dialog::alert {text,\n    text \"Aya\" ::plain :{dialog.alert}\n}\n\n.#? ::str dialog.warning\\n  display a warning message with the given message\ndef dialog::warning {text,\n    text \"Aya\" ::warn :{dialog.alert}\n}\n\n.#? ::str dialog.error\\n  display an error message with the given message\ndef dialog::error {text,\n    text \"Aya\" ::error :{dialog.alert}\n}\n\n.#? ::str dialog.warn\\n  display a warning message with the given message\ndef dialog::warn {text,\n    text \"Aya\" ::warn :{dialog.alert}\n}\n\n.#? ::str ::str ::str dialog.yesno\\n  display a dialog box with the question ::str1. ::str2 and ::str3 return true and false respectively\ndef dialog::yesno {question yes no,\n    question [yes no] \"Aya\" ::plain :{dialog.confirm}\n}\n\n.#? message::str dialog.confirm\\n  Return 1 if the user presses okay and 0 otherwise\ndef dialog::confirm {question,\n    question [\"Okay\" \"Cancel\"] \"Aya\" ::plain :{dialog.confirm}\n}\n\n.#? ::str ::list dialog.buttons\\n  display a dialog box with buttons for each of the options in L. Returns the item in the list as a string.\ndef dialog::buttons {question options::list,\n    question options \"Aya\" ::question :{dialog.buttons}\n}\n\n.#? ::str ::list dialog.dropdown\\n  display a dialog box with a dropdown selection of the options in L\ndef dialog::dropdown {question options::list,\n    question options \"Aya\" ::question :{dialog.dropdown}\n}\n\n.#? dialog.choosefile\\n  open a file selection window. return the full path of the selected file\ndef dialog::choosefile {\n    :{dialog.choosefile}\n}\n"};